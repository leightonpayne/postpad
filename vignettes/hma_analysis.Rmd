---
title: "Hma Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Hma Analysis}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

```{r}
# Make all calls to progressr print a progress bar.
progressr::handlers(global = TRUE)
progressr::handlers("cli")
library(ggplot2)
```

```{r}
path_wd <- "D:/payle484/embedded_sys/"

path_padlocout_master <- fs::path_join(c(path_wd, "padlocout/padlocout_master.csv"))
padlocout_master <- read_padlocout_master(path_padlocout_master)

path_refseq_db <- "D:/payle484/refseq/"

path_refseq_db_index <- fs::path_join(c(path_refseq_db, "index.txt"))
refseq_db_index <- read_db_index(path_refseq_db_index)
```

```{r}
# DUMP ALL SYSTEMS WITH PSEUDOGENES?
# ------------------------------------------------------------------------------

padlocout_master_has_pseudo <- dplyr::mutate(
  padlocout_master,
  has_pseudo = dplyr::if_else(
    stringr::str_detect(target.name, "^pseudo_sub*"), TRUE, FALSE
  )
)

padlocout_master_no_pseudo <- dplyr::filter(
  padlocout_master_has_pseudo,
  all(has_pseudo == FALSE),
  .by = c(seqid, system, system.number)
)

padlocout_master_shuffling <- dplyr::select(
  padlocout_master_no_pseudo,
  -c(all.domains, best.hits, has_pseudo)
) %>%
  dplyr::filter(stringr::str_detect(system, "^HEC-*", negate = TRUE))
  
path <- "D:/payle484/shuffling/padloc_all.csv"
readr::write_csv(padlocout_master_shuffling, path)

```

```{r}
# ASSSIGN A UNIQUE ID TO EACH SYSTEM
# ------------------------------------------------------------------------------

system_id_group <- c("genome.accession", "seqid", "system", "system.number")

padlocout_master_ids <- mutate_system_id(padlocout_master, "unq_system")

```

```{r}
# GENERATE GENERAL SUMMARIES
# ------------------------------------------------------------------------------

summary_system_count <- summarise_system_count(padlocout_master)

summary_system_overlap <- summarise_system_overlap(padlocout_master)

summary_protein_overlap <- summarise_protein_overlap(padlocout_master)

```

```{r}
# BUILD HMA LOCI
# ------------------------------------------------------------------------------

# Filter master padlocout table for HMA systems.
padlocout_hma <- dplyr::filter(padlocout_master_ids, system == "hma")

# Report the total number of HMA systems
padlocout_hma %>%
  dplyr::group_by(unq_system) %>%
  glue::glue_data("Total Hma systems: {dplyr::n_groups(.)}")

# # Extract GFF information of surrounding genes to 'build' loci.
# future::plan(future.callr::callr, workers = 32)
# hma_loci_06 <- build_loci(padlocout_hma, refseq_db_index, path_refseq_db, 6)
# hma_loci_06_rds_path <- fs::path_join(c(path_wd, "rds/hma_loci_06.rds"))
# readr::write_rds(hma_loci_06, hma_loci_06_rds_path)

# # Extract GFF information of surrounding genes to 'build' loci.
# future::plan(future.callr::callr, workers = 32)
# hma_loci_00 <- build_loci(padlocout_hma, index, path_db, 0)
# hma_loci_00_rds_path <- fs::path_join(c(path_wd, "rds/hma_loci_00.rds"))
# readr::write_rds(hma_loci_00, hma_loci_00_rds_path)

# Read in pre-built loci.
hma_loci_06_rds_path <- fs::path_join(c(path_wd, "rds/hma_loci_06.rds"))
hma_loci_06 <- readr::read_rds(hma_loci_06_rds_path)

# Separate the attributes column and just keep the "Name" attribute (i.e. the 
# protein name; WP_...) and "locus_tag".
hma_loci_attr <- gff_separate_attributes(hma_loci_06, keep = c("Name", "locus_tag"))

```

```{r}
# EVALUATE THE STATE OF HMA LOCI: PSEUDOGENES / MISSING GENES
# ------------------------------------------------------------------------------

# Generate pseudogene summary tables for a range of surrounding genes.
pseudo_summaries <- purrr::map(
  .x = 0:6, 
  .f = function(x) {
    a <- reduce_loci(hma_loci_06, x)
    b <- loci_summarise_pseudos(a, 6 - x)
    b
  },
  .progress = TRUE
)

pseudo_summaries_by_gene <- purrr::list_transpose(pseudo_summaries) %>% 
  purrr::pluck(1) %>%
  dplyr::bind_rows()

pseudo_summaries_by_system <- purrr::list_transpose(pseudo_summaries) %>% 
  purrr::pluck(2) %>%
  dplyr::bind_rows()

names <- tibble::tribble(
  ~ is_adjacent, ~ is_pseudo, ~ is_missing,                        ~ name,
          FALSE,       FALSE,        FALSE,    "Is system and not pseudo",
          FALSE,        TRUE,        FALSE,     "Is system and is pseudo",
           TRUE,       FALSE,        FALSE,  "Is adjacent and not pseudo",
           TRUE,        TRUE,        FALSE,   "Is adjacent and is pseudo",
           TRUE,          NA,         TRUE,  "Is adjacent and is missing"
)

df <- dplyr::left_join(pseudo_summaries_by_gene, names)

ggplot(df, aes(x = loci_limits, y = n, fill = name)) +
  geom_col() +
  labs(x = "Loci limits", y = "Genes in locus (#)", fill = "Combinations") + 
  theme_minimal() +
  scale_fill_viridis_d(option = "mako", begin = 0.25, end = 1) +
  scale_y_continuous(
    breaks = seq(0, max(dplyr::summarise(df, n = sum(n), .by = "loci_limits")), 2000),
    # labels = scales::label_percent(accuracy = 1)
  ) +
  scale_x_continuous(
    breaks = seq(min(df$loci_limits), max(df$loci_limits), 1)
  )

# path_plot <- fs::path_join(c(path_wd, "img/01_pseudo_counts.png"))
# ggsave(path_plot, width = 20, height = 8, units = "cm")

names <- tibble::tribble(
  ~ has_adj_pseudo, ~ has_adj_missing,                       ~ name,
             FALSE,             FALSE, "Has no adjacent pseudo and has no adjacent missing",
              TRUE,             FALSE,    "Has adjacent pseudo and has no adjacent missing",
              TRUE,              TRUE,       "Has adjacent pseudo and has adjacent missing",
             FALSE,              TRUE,    "Has no adjacent pseudo and has adjacent missing"
)

df <- dplyr::left_join(pseudo_summaries_by_system, names)

ggplot(df, aes(x = loci_limits, y = proportion, fill = name)) +
  geom_col() +
  labs(x = "Loci limits", y = "Proportion of loci (%)", fill = "Combinations") + 
  theme_minimal() +
  scale_fill_viridis_d(option = "mako", begin = 0.25, end = 1) +
  scale_y_continuous(
    breaks = seq(0, 1, 0.1),
    labels = scales::label_percent(accuracy = 1)
  ) +
  scale_x_continuous(
    breaks = seq(min(df$loci_limits), max(df$loci_limits), 1)
  )

# path_plot <- fs::path_join(c(path_wd, "img/02_pseudo_proportion.png"))
# ggsave(path_plot, width = 20, height = 8, units = "cm")

```

```{r}
# REMOVE NON-SYSTEM PSEUDOGENES AND MISSING GENES AND RE-BUILD LOCI
# ------------------------------------------------------------------------------

# Identify which loci have pseudogenes
loci_w_pseudos <- loci_identify_pseudos(hma_loci_06)

# # Extract a list of genomes that need rebuilding, w/ pseudogenes removed
# genomes_to_rebuild <- unique(dplyr::pull(loci_w_pseudos, genome.accession))
# 
# # Filter the database index for genomes that need rebuilding
# refseq_db_index_rebuild <- dplyr::filter(
#   refseq_db_index, genome.accession %in% genomes_to_rebuild
# )
# 
# # Filter the padlocout table for genomes that need rebuilding
# padlocout_hma_affected <- dplyr::filter(
#   padlocout_hma, genome.accession %in% genomes_to_rebuild
# )
# 
# # Filter the current loci for those that are ok
# hma_loci_06_ok <- dplyr::filter(
#   hma_loci_06, ! genome.accession %in% genomes_to_rebuild
# )
# 
# # Re-build the affected loci w/o pseudogenes
# hma_loci_06_w_pseudos_rebuilt <- build_loci_wo_pseudos(
#   padlocout_hma_affected, refseq_db_index_rebuild, path_refseq_db, 6
# )
# 
# # Join the loci tbls together
# hma_loci_06_no_pseudos <- dplyr::bind_rows(
#   hma_loci_06_ok, hma_loci_06_w_pseudos_rebuilt
# )
# hma_loci_06_no_pseudos_path <- fs::path_join(c(path_wd, "rds/hma_loci_06_no_pseudos.rds"))
# readr::write_rds(hma_loci_06_no_pseudos, hma_loci_06_no_pseudos_path)
# 
# # Just read in the pre-built loci
# hma_loci_06_no_pseudos_path <- fs::path_join(c(path_wd, "rds/hma_loci_06_no_pseudos.rds"))
# hma_loci_06_no_pseudos <- readr::read_rds(hma_loci_06_no_pseudos_path)
# 
# # Check that there's been no funny business
# check_original <- dplyr::distinct(hma_loci_06, genome.accession, seqid, system, system.number) %>%
#   dplyr::arrange(genome.accession, seqid, system, system.number)
# check_no_pseudos <- dplyr::distinct(hma_loci_06_no_pseudos, genome.accession, seqid, system, system.number) %>%
#   dplyr::arrange(genome.accession, seqid, system, system.number)
# 
# identical(check_original, check_no_pseudos)

# Re-build everyting w/o pseudogenes
# hma_loci_06_all_no_pseudos <- build_loci_wo_pseudos(
#   padlocout_hma, refseq_db_index, path_refseq_db, 6
# )
# hma_loci_06_all_no_pseudos_path <- fs::path_join(c(path_wd, "rds/hma_loci_06_all_no_pseudos.rds"))
# readr::write_rds(hma_loci_06_all_no_pseudos, hma_loci_06_all_no_pseudos_path)

# Just read in the pre-built loci
hma_loci_06_all_no_pseudos_path <- fs::path_join(c(path_wd, "rds/hma_loci_06_all_no_pseudos.rds"))
hma_loci_06_all_no_pseudos <- readr::read_rds(hma_loci_06_all_no_pseudos_path)


```

```{r}
# CHECK AGAIN TO MAKE SURE PSEUDOS WERE REMOVED
# ------------------------------------------------------------------------------

hma_loci_06_all_no_pseudos_prepped <- dplyr::select(
  hma_loci_06_all_no_pseudos, - c(relative.position_w_pseudo, contig.end_w_pseudos)
) %>%
  gff_collect_attributes()


# Generate pseudogene summary tables for a range of surrounding genes.
pseudo_summaries_2 <- purrr::map(
  .x = 0:6, 
  .f = function(x) {
    a <- reduce_loci(hma_loci_06_all_no_pseudos_prepped, x)
    b <- loci_summarise_pseudos(a, 6 - x)
    b
  },
  .progress = TRUE
)

pseudo_summaries_by_gene_2 <- purrr::list_transpose(pseudo_summaries_2) %>% 
  purrr::pluck(1) %>%
  dplyr::bind_rows()

pseudo_summaries_by_system_2 <- purrr::list_transpose(pseudo_summaries_2) %>% 
  purrr::pluck(2) %>%
  dplyr::bind_rows()

names <- tibble::tribble(
  ~ is_adjacent, ~ is_pseudo, ~ is_missing,                        ~ name,
          FALSE,       FALSE,        FALSE,    "Is system and not pseudo",
          FALSE,        TRUE,        FALSE,     "Is system and is pseudo",
           TRUE,       FALSE,        FALSE,  "Is adjacent and not pseudo",
           TRUE,        TRUE,        FALSE,   "Is adjacent and is pseudo",
           TRUE,          NA,         TRUE,  "Is adjacent and is missing"
)

df <- dplyr::left_join(pseudo_summaries_by_gene_2, names)

ggplot(df, aes(x = loci_limits, y = n, fill = name)) +
  geom_col() +
  labs(x = "Loci limits", y = "Genes in locus (#)", fill = "Combinations") + 
  theme_minimal() +
  scale_fill_viridis_d(option = "mako", begin = 0.25, end = 1) +
  scale_y_continuous(
    breaks = seq(0, max(dplyr::summarise(df, n = sum(n), .by = "loci_limits")), 2000),
    # labels = scales::label_percent(accuracy = 1)
  ) +
  scale_x_continuous(
    breaks = seq(min(df$loci_limits), max(df$loci_limits), 1)
  )

# path_plot <- fs::path_join(c(path_wd, "img/03_pseudo_counts.png"))
# ggsave(path_plot, width = 20, height = 8, units = "cm")

names <- tibble::tribble(
  ~ has_adj_pseudo, ~ has_adj_missing,                       ~ name,
             FALSE,             FALSE, "Has no adjacent pseudo and has no adjacent missing",
              TRUE,             FALSE,    "Has adjacent pseudo and has no adjacent missing",
              TRUE,              TRUE,       "Has adjacent pseudo and has adjacent missing",
             FALSE,              TRUE,    "Has no adjacent pseudo and has adjacent missing"
)

df <- dplyr::left_join(pseudo_summaries_by_system_2, names)

ggplot(df, aes(x = loci_limits, y = proportion, fill = name)) +
  geom_col() +
  labs(x = "Loci limits", y = "Proportion of loci (%)", fill = "Combinations") + 
  theme_minimal() +
  scale_fill_viridis_d(option = "mako", begin = 0.25, end = 1) +
  scale_y_continuous(
    breaks = seq(0, 1, 0.1),
    labels = scales::label_percent(accuracy = 1)
  ) +
  scale_x_continuous(
    breaks = seq(min(df$loci_limits), max(df$loci_limits), 1)
  )

# path_plot <- fs::path_join(c(path_wd, "img/04_pseudo_proportion.png"))
# ggsave(path_plot, width = 20, height = 8, units = "cm")

```

```{r}
# EVALUATE THE STATE OF HMA LOCI: DISTANCES TO ENDS OF CONTIGS
# ------------------------------------------------------------------------------

# DISTANCES TO ENDS OF CONTIGS
# ............................

padlocout_hma_no_pseudo <- dplyr::filter(
  hma_loci_06_all_no_pseudos, !is.na(target.name)
)

# Add columns for system limits
padlocout_hma_system_limits <- add_group_limits(
  padlocout_hma_no_pseudo, relative.position, relative.position, .by = "unq_system"
)

# Add columns for distance to contig ends
padlocout_hma_contig_distance <- dplyr::mutate(
  padlocout_hma_system_limits,
  distance_to_contig_start = min_unq_system_relative.position - 1,
  distance_to_contig_end = contig.end - max_unq_system_relative.position,
  min_distance_to_contig_border = min(distance_to_contig_start, distance_to_contig_end),
  max_distance_to_contig_border = max(distance_to_contig_start, distance_to_contig_end),
  .by = "unq_system"
)

summary_hma_contig_distance <- padlocout_hma_contig_distance %>%
  dplyr::mutate(
    min_distance_lt_3 = dplyr::if_else(min_distance_to_contig_border < 3, TRUE, FALSE),
    max_distance_lt_3 = dplyr::if_else(max_distance_to_contig_border < 3, TRUE, FALSE)
  ) %>% 
  dplyr::summarise(n = dplyr::n(), .by = c("min_distance_lt_3", "max_distance_lt_3")) %>% 
  mutate_proportion(col = n) %>%
  klip()

distance_cumprop_tbl <- padlocout_hma_contig_distance %>%
  tidyr::nest(
    .by = c(
      "unq_system",
      "distance_to_contig_start", 
      "distance_to_contig_end",
      "min_distance_to_contig_border",
      "max_distance_to_contig_border"
    )
  ) %>%
  tidyr::pivot_longer(
    cols = c(
      distance_to_contig_start,
      distance_to_contig_end, 
      min_distance_to_contig_border, 
      max_distance_to_contig_border
    ) 
  ) %>%
  dplyr::group_by(name) %>% 
  dplyr::arrange(value) %>% 
  dplyr::add_count(value) %>% 
  dplyr::distinct(name, value, n) %>% 
  dplyr::mutate(cumprop = cumsum(n) / sum(n))

approx_yint <- function(data, xcol, ycol, xint) {
  x <- dplyr::pull(data, {{ xcol }})
  y <- dplyr::pull(data, {{ ycol }})
  f <- approxfun(y, x)
  opt <- optimise(function(i) abs(f(i) - xint), interval = range(y))
  yint <- purrr::pluck(opt, "minimum")
  yint
}

xint <- 2

approx_intercepts <- distance_cumprop_tbl %>%
  tidyr::nest() %>%
  dplyr::mutate(
    distance = xint,
    cumulative_prop = purrr::map_dbl(data, ~ approx_yint(.x, value, cumprop, xint))
  ) %>%
  dplyr::select(-data) %>%
  klip()

facet_names <- c(
  distance_to_contig_end = "Number of genes between system and end of contig (i.e. RHS of system)",
  distance_to_contig_start = "Number of genes between system and start of contig (i.e. LHS of system)",
  max_distance_to_contig_border = "Maximum number of genes between the system and a contig border (i.e there is a lack of genes on both sides)",
  min_distance_to_contig_border = "Minimum number of genes between the system and a contig border (i.e there is a lack of genes on one side)"
)

distance_cumprop_tbl %>%
  ggplot(aes(x = value, y = cumprop)) +
  geom_line() +
  facet_grid(cols = vars(name)) +
  # geom_vline(aes(xintercept = xint), data = approx_intercepts, colour = "red", linetype = "dashed") +
  # geom_hline(aes(yintercept = yint), data = approx_intercepts, colour = "red", linetype = "dashed") +
  theme_minimal() +
  labs(x = "Distance (i.e. no. of genes)", y = "Cumulative proportion of Hma systems")

# path_plot <- fs::path_join(c(path_wd, "img/05_contig_end_distance.png"))
# ggsave(path_plot, width = 20, height = 8, units = "cm")

distance_cumprop_tbl %>%
  # dplyr::filter(dplyr::between(cumprop, 0, 0.5)) %>%
  ggplot(aes(x = value, y = cumprop)) +
  # geom_line(aes(colour = name)) +
  geom_line() +
  facet_grid(cols = vars(name)) +
  # geom_vline(aes(xintercept = xint), data = approx_intercepts, colour = "red", linetype = "dashed") +
  # geom_hline(aes(yintercept = yint), data = approx_intercepts, colour = "red", linetype = "dashed") +
  theme_minimal() +
  labs(x = "Distance (i.e. no. of genes)", y = "Cumulative proportion of Hma systems")


filtered <- distance_cumprop_tbl %>%
  dplyr::filter(dplyr::between(value, 0, 6))

cumprop_at_distance <- filtered %>%
  dplyr::filter(value == xint)

filtered %>%
  ggplot(aes(x = value, y = cumprop)) +
  geom_col() +
  facet_grid(cols = vars(name), labeller = as_labeller(facet_names, default = label_wrap_gen(width = 25))) +
  theme_minimal() +
  labs(x = "Number of genes", y = "Cumulative proportion of Hma systems") +
  scale_y_continuous(
    breaks = seq(0, round(max(filtered$cumprop), 2), 0.02),
    labels = scales::label_percent(accuracy = 1)
  ) +
  scale_x_continuous(
    breaks = seq(min(filtered$value), max(filtered$value), 1)
  ) +
  geom_hline(aes(yintercept = cumprop), data = cumprop_at_distance, colour = "red", linetype = "dashed")

# path_plot <- fs::path_join(c(path_wd, "img/06_contig_end_distance.png"))
# ggsave(path_plot, width = 20, height = 8, units = "cm")

```

```{r}
# SELECT AN APPROPRIATE NUMBER OF SURROUNDING GENES TO IDENTIFY UNIQUE SYSTEMS
# ------------------------------------------------------------------------------

# Fix up the locus mins and maxes
# TODO: Bake this into `build_loci_wo_pseudos()` somehow
hma_loci_06_fixed <- hma_loci_06_all_no_pseudos_prepped %>%
  dplyr::mutate(
    locus.min = min(relative.position[!is.na(target.name)]) - 6, 
    locus.max = max(relative.position[!is.na(target.name)]) + 6, 
    .by = c("genome.accession", "seqid", "system", "system.number")
  )

hma_loci_03 <- reduce_loci(hma_loci_06_fixed, 3)

hma_loci_attsep <- gff_separate_attributes(hma_loci_03)

```

```{r}
# EXTRACT GENES SURROUNDING HMA SYSTEMS TO DETERIME UNIQUE LOCI
# ------------------------------------------------------------------------------

# Prepare a table for extracting sequences.
seq_extract_index <- make_seq_extract_index(hma_loci_attsep, refseq_db_index, "Name", "path_faa")
seq_extract_index_unique <- dplyr::distinct(seq_extract_index, id, .keep_all = TRUE)

# Extract sequences; 32 workers, callr, 15,795 proteins ~ 600 sec (10 min)
future::plan(future.callr::callr, workers = 32)
seqs <- future_seq_extract(path_refseq_db, seq_extract_index_unique)
seqs_unlisted <- unlist(seqs)
hma_adjacent_proteins_path <- fs::path_join(c(path_wd, "adjacent_proteins/hma_adjacent_proteins.faa"))
readr::write_lines(seqs_unlisted, hma_adjacent_proteins_path)

```

```{r}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# CLUSTER THE PROTEINS W/ MMSEQS 
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
```

```{r}
# ASSIGN CLUSTER NAMES TO PROTEINS IN LOCI
# ------------------------------------------------------------------------------

path_clustering <- fs::path_join(c(path_wd, "mmseqs_cluster_hma_adjacent/results/"))

# Read in the cluster key generated by mmseqs.
path_cluster_key <- fs::path_join(c(path_clustering, "clusters/hma_adjacent/hma_adjacent.tsv"))
cluster_key <- read_mmseqs_cluster_tsv(path_cluster_key)

hma_loci_clusters <- dplyr::left_join(
  hma_loci_attsep, cluster_key, 
  by = dplyr::join_by("Name" == "clu_member")
)

# Assign each system gene to a cluster based on their name
hma_loci_clusters_filled <- dplyr::mutate(
  hma_loci_clusters,
  clu_representative = dplyr::if_else(
    is.na(target.name), clu_representative, protein.name
  ) 
)

# Confirm that all adjacent proteins have been assigned to a cluster
hma_loci_clusters_filled %>% 
  dplyr::filter(is.na(target.name)) %>%
  dplyr::pull(clu_representative) %>% 
  is.na() %>% any()

# NOTE: There were no duplicates so none of this is needed
#
# # Read in the duplicates key generated by seqkit.
# path_duplicates_key <- fs::path_join(c(
#   path_clustering, "fasta_filtered/hma_adjacent_seqkit_duplicates.tsv"
# ))
# duplicates_key <- read_seqkit_duplicates(duplicates_key_path)
# 
# # Unnest the duplicates key so each row is a distinct pair of representative 
# # and member.
# duplicates_key_unnested <- tidyr::unnest(duplicates_key, dup_member)
# duplicates_key_distinct <- dplyr::distinct(duplicates_key_unnested)
# 
# # Assign the representative names to duplicate proteins that got discarded by 
# # seqkit before clustering with mmseqs.
# hma_loci_dups <- dplyr::left_join(
#   hma_loci_attr, duplicates_key_distinct, 
#   by = dplyr::join_by("Name" == "dup_member")
# )
# hma_loci_dups_filled <- dplyr::mutate(
#   hma_loci_dups, 
#   dup_representative = ifelse(is.na(dup_representative), Name, dup_representative)
# )
# 
# # Assign the cluster names.
# hma_loci_clusters <- dplyr::left_join(hma_loci_dups_filled, cluster_key, by = dplyr::join_by("dup_representative" == "clu_member"))
```

```{r}
# SUMMARISE THE DIFFERENT LOCUS STRUCTURES
# ------------------------------------------------------------------------------

# Flip loci so all systems are on the same strand
loci_tbl_flip_strands <- function(loci_tbl, anchor) {
  needs_flip <- dplyr::mutate(
    loci_tbl,
    # `min(c("+", "-")) == "-"`
    flip = dplyr::if_else(min(strand[protein.name == anchor], na.rm = TRUE) == "-", TRUE, FALSE),
    new_pos = dplyr::if_else(flip == TRUE, - relative.position, relative.position),
    .by = c("genome.accession", "seqid", "system", "system.number")
  )
  flipped <- dplyr::arrange(
    needs_flip,
    genome.accession, seqid, system, system.number, new_pos
  )
  out <- dplyr::select(flipped, - c(flip, new_pos))
  out
}

hma_loci_clusters_flipped <- loci_tbl_flip_strands(hma_loci_clusters_filled, "HmaA")

loci_tbl_nested <- loci_tbl_nest_structure(hma_loci_clusters_flipped)

loci_tbl_nested %>%
  dplyr::mutate(proportion = round(locus_structure_n / sum(locus_structure_n), digits = 4)) %>%
  dplyr::select(-data) %>%
  dplyr::mutate(locus_id = dplyr::row_number()) %>%
  dplyr::rename(count = locus_structure_n) %>%
  dplyr::select(locus_id, count, proportion) %>%
  dplyr::slice_head(n = 10) %>%
  # dplyr::summarise(n = sum(proportion)) %>%
  klip()

```

```{r}
# SELECT A SAMPLE OF UNIQUE HMA SYSTEMS
# ------------------------------------------------------------------------------

loci_tbl_locus_structure <- loci_tbl_add_locus_structure(hma_loci_clusters_flipped)

loci_tbl_locus_structure_hma_lims <- loci_tbl_locus_structure %>%
  dplyr::mutate(
    min_sys_relative.position = min(relative.position[!is.na(target.name)]),
    max_sys_relative.position = max(relative.position[!is.na(target.name)]),
    .by = c(genome.accession, seqid, system, system.number)
  )

# Add columns for distance to contig ends
loci_tbl_locus_structure_contig_distance <- dplyr::mutate(
  loci_tbl_locus_structure_hma_lims,
  distance_to_contig_start = min_sys_relative.position - 1,
  distance_to_contig_end = contig.end - max_sys_relative.position,
  min_distance_to_contig_border = min(distance_to_contig_start, distance_to_contig_end),
  max_distance_to_contig_border = max(distance_to_contig_start, distance_to_contig_end),
  .by = c(genome.accession, seqid, system, system.number)
)

loci_tbl_locus_structure_contig_distance_nested <- loci_tbl_locus_structure_contig_distance %>%
  tidyr::nest(.by = c(locus_structure, genome.accession, seqid, system, system.number, min_distance_to_contig_border))

loci_sample_nested <- loci_tbl_locus_structure_contig_distance_nested %>%
  dplyr::slice_max(order_by = tibble::tibble(min_distance_to_contig_border, system.number), n = 1, by = locus_structure, with_ties = FALSE)

# loci_tbl_nested_sample <- function(loci_tbl_nested) {
#   sample <- purrr::map(loci_tbl_nested$data, ~ dplyr::slice_sample(.x))
#   loci_tbl_nested$data <- sample
#   loci_tbl_nested
# }
# 
# # Set seed for reproducible `dplyr::slice_sample()`.
# set.seed(14561983)
# loci_sample_nested <- loci_tbl_nested_sample(loci_tbl_nested)

sampled_genomes <- dplyr::pull(loci_sample_nested, genome.accession)
sampled_loci <- dplyr::select(loci_sample_nested, genome.accession, seqid, system, system.number)

padlocout_master_sampled <- dplyr::filter(padlocout_master, genome.accession %in% sampled_genomes)

```

```{r}
# INVESTIGATE CHARACTERISTICS OF THE SAMPLED HMA LOCI
# ------------------------------------------------------------------------------

# FROM NOW ON WE'RE ONLY INTERESTED IN UNIQUE HMA SYSTEMS
padlocout_hma_unique <- 
  dplyr::left_join(
    sampled_loci, 
    padlocout_hma, 
    by = dplyr::join_by(genome.accession, seqid, system, system.number),
    multiple = "all"
  )

# Drop 'other' models.
padlocout_master_sampled_no_other <- dplyr::filter(padlocout_master_sampled, !stringr::str_detect(system, "_other"))
# Drop CRISPR arrays and ncRNAs.
padlocout_master_sampled_no_ncrna <- dplyr::filter(padlocout_master_sampled_no_other, relative.position %% 1 == 0)
# Drop HECs.
padlocout_master_sampled_no_hecs <- dplyr::filter(padlocout_master_sampled_no_ncrna, !stringr::str_detect(system, "HEC"))

# Resolve overlapping systems.
padlocout_master_sampled_no_overlaps <- padlocout_resolve_overlaps(padlocout_master_sampled_no_hecs)

# Drop HMAs
padlocout_master_sampled_no_hma <- dplyr::filter(padlocout_master_sampled_no_overlaps, system != "hma")

# Join the unique HMA systems.
padlocout_master_sampled_no_overlaps <- dplyr::bind_rows(
  padlocout_master_sampled_no_hma, padlocout_hma_unique
)


# ISLAND ANALYSIS GRAPH

# hma_loci_00 <- reduce_loci(hma_loci_06, 6)
# hma_embedded_genes <- dplyr::filter(hma_loci_00, is.na(target.name))
# hma_embedded_positions <- dplyr::select(
#   hma_embedded_genes, genome.accession, seqid, relative.position
# ) %>% 
#   dplyr::mutate(
#     embedded_in_hma = TRUE
#   )

# REDUCE LOCI DOWN TO JUST EMBEDDED GENES (NO SURROUNDING)

hma_loci_00 <- reduce_loci(hma_loci_06, 6)
hma_loci_00_unq <- dplyr::left_join(
  sampled_loci, hma_loci_00,
  by = dplyr::join_by(genome.accession, seqid, system, system.number),
  multiple = "all"
)


# SUMMARISE EMBEDDED GENE COUNTS

embedded_counts <- hma_loci_00_unq %>% 
  dplyr::mutate(embedded_count = sum(is.na(target.name)), .by = c(genome.accession, seqid, system, system.number)) %>%
  tidyr::nest(.by = c(genome.accession, seqid, system, system.number, embedded_count))

embedded_counts_summary <- embedded_counts %>% 
  summarise_proportion(.by = "embedded_count") %>% 
  dplyr::arrange(embedded_count)

# Number of systems, per number of embedded genes
embedded_counts_summary %>% 
  # dplyr::filter(embedded_count > 0) %>% 
  # dplyr::summarise(n = sum(n), proportion = sum(proportion))
  klip()

embedded_counts_summary %>%
  ggplot2::ggplot() +
  ggplot2::geom_col(aes(x = embedded_count, y = n)) +
  ggplot2::scale_x_continuous(breaks = seq(0, 6, 1)) +
  ggplot2::scale_y_continuous(breaks = seq(0, max(embedded_counts_summary$n), by = 100)) +
  ggplot2::theme_minimal()

filepath <- fs::path_join(c(path_wd, "pdf/f1B.pdf"))
ggsave(filename = filepath, units = "mm", width = 52.536, height = 52.536)

# Number of embedded genes total
embedded_counts %>% dplyr::summarise(n = sum(embedded_count))

hma_embedded_genes <- dplyr::filter(hma_loci_00_unq, is.na(target.name))
hma_embedded_positions <- dplyr::select(
  hma_embedded_genes, genome.accession, seqid, relative.position
) %>%
  dplyr::mutate(
    embedded_in_hma = TRUE
  )

range <- 0:25

# range <- seq(0, 8000, 100)

result <- purrr::map(.x = range, .f = function(i) {
  
  # Filter for relevant genomes
  padlocout_system_limits <- add_group_limits(
    padlocout_master_sampled_no_overlaps, 
    relative.position, 
    relative.position, 
    .by = c("genome.accession", "seqid", "system.number", "system")
  )
  
  # Find islands
  # ~ 60s
  padlocout_islands_positions <- group_by_distance(
    padlocout_system_limits, 
    min_system_relative.position,
    max_system_relative.position, 
    n = i, 
    name = "island", 
    .by = c("genome.accession", "seqid")
  )
  
  padlocout_islands_nested <- tidyr::nest(
    padlocout_islands_positions, 
    .by = c("genome.accession", "seqid", "island", "system", "system.number")
  )
  
  # Filter for islands with hma
  padlocout_islands_hma <- dplyr::filter(
    padlocout_islands_nested, 
    any(system %in% "hma"), 
    .by = c(genome.accession, seqid, island)
  ) 
  
  islands_hma_sample_unnested <- 
    tidyr::unnest(padlocout_islands_hma, data)
  
  tmp <- islands_hma_sample_unnested %>%
    group_by_position(
      col = relative.position,
      n = 1,
      name = "tmp",
      .by = c("genome.accession", "seqid", "system.number", "system")
    ) %>%
    dplyr::left_join(
      hma_embedded_positions, 
      by = dplyr::join_by(genome.accession, seqid, relative.position)
    ) %>%
    dplyr::mutate(
      hma_w_embedded = dplyr::if_else(system == "hma" & max(tmp) > 1, TRUE, FALSE),
      .by = c("genome.accession", "seqid", "system.number", "system")
    ) %>%
    dplyr::mutate(
      hma_w_embedded = dplyr::if_else(any(hma_w_embedded == TRUE), TRUE, FALSE),
      hma_in_island = dplyr::if_else(any(system != "hma" & is.na(embedded_in_hma)), TRUE, FALSE),
      .by = c("genome.accession", "seqid", "island") 
    )
  
  tmp2 <- tmp %>%
    tidyr::nest(.by = c("genome.accession", "seqid", "island", "hma_w_embedded", "hma_in_island"))
  
  summary <- tmp2 %>%
    dplyr::summarise(n = dplyr::n(), .by = c("hma_w_embedded", "hma_in_island"))
  
  summary
  
}, .progress = TRUE)

result_bound <- purrr::imap(result, function(x, idx) dplyr::mutate(x, i = (idx - 1))) %>% dplyr::bind_rows()

result_bound_2 <- result_bound %>% dplyr::mutate(
  col1 = dplyr::if_else(hma_w_embedded, "w_embedded_genes", "wo_embedded_genes"),
  col2 = dplyr::if_else(hma_in_island, "in_island", "in_isolation")
)

df <- tibble::tibble(
  col1 = c(TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE),
  col2 = c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE),
  n = c(315, 131, 416, 608, 328, 148, 399, 595),
  i = c(1, 1, 1, 1, 2, 2, 2, 2)
)

result_bound_2 %>%
  ggplot2::ggplot(ggplot2::aes(x = factor(i), y = n)) +
  ggplot2::geom_bar(stat = "identity") +
  ggplot2::facet_grid(col1 ~ col2) +
  ggplot2::labs(x = "Island limits (no. of genes either side of Hma)", y = "Count") +
  ggplot2::theme_minimal()

result_bound_2 %>%
  
  dplyr::mutate(
    col_comb = factor(glue::glue("{col2}_{col1}")),
    order = stats::ave(n, col_comb, FUN = seq_along)
  ) %>%
  
  # dplyr::filter(
  #   dplyr::between(i, 1, 30)
  # ) %>%
  
  ggplot(., aes(x = as.factor(i), y = n, fill = col_comb)) +
  geom_bar(stat = "identity", position = "stack", alpha = 1, width = 1) +
  scale_fill_viridis_d(option = "mako", begin = 0.25, end = 1) +
  labs(x = "Island limits (no. of genes either side of Hma)", y = "Count", fill = "col_comb") +
  # facet_grid(~col1) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
  ) +
  theme_minimal() #+
  # guides(fill = FALSE)

# path_plot <- fs::path_join(c(path_wd, "pdf/F1_island_analysis.pdf"))
# ggsave(path_plot, width = 79.6, height = 79.6, units = "mm")

# Proportion of Hma systems in isolation
result_bound_2 %>% 
  dplyr::filter(i == 25) %>% 
  dplyr::mutate(proportion = n/sum(n)) %>% 
  dplyr::filter(col2 == "in_isolation") %>%
  dplyr::summarise(n = sum(n), proportion = sum(proportion)) %>%
  dplyr::pull(proportion)

# Proportion of Hma systems in isolation, that also have embedded genes
result_bound_2 %>% 
  dplyr::filter(i == 25) %>% 
  dplyr::filter(col2 == "in_isolation") %>%
  dplyr::mutate(proportion = n/sum(n)) %>%
  dplyr::filter(col1 == "w_embedded_genes") %>%
  dplyr::pull(proportion)

#### KNOWN SYSTEMS EMBEDDED
  


```

```{r}
# EXTRACT AND CLUSTER PROTEINS EMBEDDED IN HMA SYSTEMS
# ------------------------------------------------------------------------------

# Separate the attributes column and just keep the "Name" attribute.
hma_embedded_genes_attr <- gff_separate_attributes(hma_embedded_genes, keep = c("Name"))

# Filter for distinct sequences.
embedded_proteins_distinct <- 
  hma_embedded_genes_attr %>% 
  dplyr::filter(is.na(target.name)) %>% 
  dplyr::select(Name) %>%
  dplyr::distinct() %>%
  dplyr::filter(!stringr::str_detect(Name, "^pseudo_sub*")) %>%
  dplyr::filter(!is.na(Name))

# Number of distinct embedded proteins
nrow(embedded_proteins_distinct)

# Write out.
path_embedded_proteins <- fs::path_join(c(path_wd, "embedded_proteins/hma_embedded_proteins.txt"))
readr::write_tsv(embedded_proteins_distinct, path_embedded_proteins, col_names = FALSE)
```

```{r}

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# EXTRACT EMBEDDED PROTEINS FROM ALL ADJACENT PROTEINS, AND CLUSTER W/ MMSEQS 
# & HH-SUITE
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

```

```{r}
# DETERMINE CLUSTERS BASED ON HMM-HMM COMPARISON
# ------------------------------------------------------------------------------

hhcat_path <- fs::path_join(c(path_wd, "all_vs_all_hma_embedded/hhsearch_out/hma_embedded_all_vs_all.hhcat"))
hhcat <- read_hhcat(hhcat_path)
hhcat_proc <- hhcat_process(hhcat)
hhcat_filt <- hhcat_filter(hhcat_proc, probability = 70, match_coverage = 70, query_coverage = 70)
hhcat_graph <- hhcat_graph(hhcat_filt)

second_order_clusters <- hhcat_graph %>% 
  dplyr::mutate(cluster = tidygraph::group_components(type = "weak")) %>%
  tidygraph::activate(nodes) %>%
  tibble::as_tibble() %>%
  dplyr::rename(clu_representative = cluster, clu_member = name)

path_embedded_mmseqs_clusters <- fs::path_join(c(path_wd, "mmseqs_cluster_hma_embedded/results/clusters/hma_embedded/hma_embedded.tsv"))
first_order_clusters <- read_mmseqs_cluster_tsv(path_embedded_mmseqs_clusters)

extended_clusters <- extend_clusters(first_order_clusters, second_order_clusters)

# Number of protein families
extended_clusters %>% dplyr::distinct(clu_ord_2) %>% nrow()

cluster_key_path <- fs::path_join(c(path_wd, "all_vs_all_hma_embedded/cluster_key.txt"))
readr::write_tsv(extended_clusters, cluster_key_path, col_names = FALSE)

```

```{r}
# SUMMARISE THE KNOWN SYSTEMS EMBEDDED IN HMA SYSTEMS
# ------------------------------------------------------------------------------

padlocout_master_sampled_no_overlaps_no_pseudo <- 
  padlocout_master_sampled_no_overlaps %>% 
  dplyr::mutate(contains_pseudo = dplyr::if_else(any(stringr::str_detect(target.name, "^pseudo_sub")), TRUE, FALSE), .by = c(genome.accession, seqid, system.number, system)) %>%
  dplyr::filter(contains_pseudo == FALSE)

tmp <- hma_embedded_genes_attr %>%
  dplyr::filter(!stringr::str_detect(Name, "^pseudo_sub")) %>%
  dplyr::select(genome.accession, seqid, relative.position, Name) %>%
  dplyr::left_join(padlocout_master_sampled_no_overlaps_no_pseudo, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
  group_by_position(col = relative.position, n = 1, name = "locus_id", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(locus_id = dplyr::cur_group_id(), .by = c("genome.accession", "seqid", "locus_id")) %>%
  group_by_position(col = relative.position, n = 1, name = "cassette_id", .by = "locus_id") %>%
  dplyr::mutate(cassette_id = dplyr::cur_group_id(), .by = c("locus_id", "cassette_id")) %>%
  dplyr::mutate(
    systems_in_cassette = paste0(unique(system), collapse = "++"),
    .by = c("cassette_id")
  ) %>%
  tidyr::nest(.by = c("cassette_id", "systems_in_cassette")) %>% 
  dplyr::summarise(n = dplyr::n(), .by = c("systems_in_cassette")) %>%
  dplyr::arrange(desc(n)) %>% 
  dplyr::mutate(systems_in_cassette = stringr::str_remove(systems_in_cassette, "NA\\+\\+|\\+\\+NA")) %>%
  # tidyr::separate_longer_delim(systems_in_cassette, "++") %>%
  dplyr::summarise(n = sum(n), .by = c("systems_in_cassette")) %>% 
  dplyr::arrange(desc(n), systems_in_cassette) %>%
  # dplyr::filter(systems_in_cassette != "NA") %>%
  dplyr::mutate(n_perc = n/sum(n)*100)
  

tmp %>% 
  dplyr::rename(system = systems_in_cassette, proportion = n_perc) %>%
  dplyr::mutate(dplyr::across(proportion, ~ round(.x, digits = 2))) %>%
  klip()

# Number of known systems encoded by embedded gene casettes
tmp %>% dplyr::summarise(n = sum(n))

order <- tmp %>% dplyr::arrange(n, systems_in_cassette) %>% dplyr::pull(systems_in_cassette)

tmp %>% 
  ggplot(aes(x = "", y = n_perc, fill = factor(systems_in_cassette, level = order))) +
  geom_col(color = "black") +
  # geom_text(aes(label = n.norm), position = position_stack(vjust = 0.5)) +
  coord_flip() +
  theme_void() +
  scale_fill_viridis_d(NULL, begin = 0.2, end = 1, direction = -1, option = "rocket") +
  guides(fill = guide_legend(reverse = TRUE, ncol = 4)) +
  theme(legend.position = "bottom")

path <- fs::path_join(c(path_wd, "pdf/f1C.pdf"))
ggsave(filename = path, device = "pdf", width = 246.2, height = 159.2, units = "mm")

# tmp <- hma_embedded_cassettes %>%
#   dplyr::left_join(extended_clusters, by = dplyr::join_by(Name == clu_member)) %>%
#   dplyr::mutate(clu_ord_2 = stringr::str_pad(clu_ord_2, 5, "left", "0")) %>%
#   dplyr::mutate(cassette = paste0(sort(clu_ord_2), collapse = "__"), .by = cassette_id) %>%
#   dplyr::distinct(cassette_id, cassette) %>%
#   dplyr::summarise(n = dplyr::n(), .by = cassette) %>%
#   dplyr::arrange(desc(n))

# SEPTU SYSTEMS EMBEDDED IN HMA, VS INDEPENDENT



# Number of Septu systems, total
summary_system_count %>% 
  dplyr::filter(system == "septu_type_I")

# Looking at all Hma systems, not just unique contexts (i.e. hma_loci_00_unq)
hma_embedded_genes_all <- dplyr::filter(hma_loci_00, is.na(target.name))

hma_embedded_genes_all_attr <- gff_separate_attributes(hma_embedded_genes_all, keep = c("Name"))

hma_embedded_genes_all_attr %>%
  dplyr::select(genome.accession, seqid, relative.position, Name) %>%
  dplyr::left_join(padlocout_master_sampled_no_overlaps, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
  group_by_position(col = relative.position, n = 1, name = "locus_id", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(locus_id = dplyr::cur_group_id(), .by = c("genome.accession", "seqid", "locus_id")) %>%
  group_by_position(col = relative.position, n = 1, name = "cassette_id", .by = "locus_id") %>%
  dplyr::mutate(cassette_id = dplyr::cur_group_id(), .by = c("locus_id", "cassette_id")) %>%
  dplyr::mutate(
    systems_in_cassette = paste0(unique(system), collapse = "++"),
    .by = c("cassette_id")
  ) %>%
  tidyr::nest(.by = c("cassette_id", "systems_in_cassette")) %>% 
  dplyr::summarise(n = dplyr::n(), .by = c("systems_in_cassette")) %>%
  dplyr::arrange(desc(n)) %>% 
  tidyr::separate_longer_delim(systems_in_cassette, "++") %>%
  dplyr::summarise(n = sum(n), .by = c("systems_in_cassette")) %>% 
  dplyr::arrange(desc(n)) %>%
  dplyr::mutate(n_perc = n/sum(n)*100) %>%
  dplyr::filter(systems_in_cassette != "NA") %>%
  dplyr::filter(systems_in_cassette == "septu_type_I")

# 163 / 23,949 = 0.68%

```

```{r}
# SUMMARISE THE GENE CASSETTES EMBEDDED IN HMA SYSTEMS
# ------------------------------------------------------------------------------

hma_embedded_genes_attr_no_pseudo <-
  hma_embedded_genes_attr %>%
  dplyr::filter(!is.na(Name) & !stringr::str_detect(Name, "^pseudo_sub*"))

hma_embedded_clusters <- dplyr::left_join(
  hma_embedded_genes_attr_no_pseudo, extended_clusters,
  by = dplyr::join_by(Name == clu_member)
) %>%
  group_by_position(relative.position, n = 1, name = "embedded_cluster", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(embedded_cluster_id = dplyr::cur_group_id(), .by = c(genome.accession, seqid, embedded_cluster)) %>%
  dplyr::mutate(cluster = stringr::str_pad(clu_ord_2, width = 5, pad = "0")) %>%
  dplyr::arrange(cluster) %>%
  dplyr::mutate(cassette = paste0(cluster, collapse = ">>"), .by = "embedded_cluster_id") %>%
  tidyr::nest(.by = c(cassette, embedded_cluster_id)) %>%
  summarise_proportion(.by = "cassette") %>%
  dplyr::arrange(desc(n))

hma_embedded_unknown <- hma_embedded_genes_attr_no_pseudo %>%
  dplyr::select(genome.accession, seqid, relative.position, Name) %>%
  dplyr::left_join(padlocout_master_sampled_no_overlaps, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
  dplyr::left_join(extended_clusters, by = dplyr::join_by(Name == clu_member)) %>%
  dplyr::filter(is.na(system)) %>%
  group_by_position(relative.position, n = 1, name = "embedded_cluster", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(embedded_cluster_id = dplyr::cur_group_id(), .by = c(genome.accession, seqid, embedded_cluster)) %>%
  dplyr::mutate(cluster = paste0("FAM_", stringr::str_pad(clu_ord_2, width = 5, pad = "0"))) %>%
  dplyr::arrange(cluster) %>%
  dplyr::mutate(cassette = paste0(cluster, collapse = ">>"), .by = "embedded_cluster_id") %>%
  tidyr::nest(.by = c(cassette, embedded_cluster_id)) %>%
  summarise_proportion(.by = "cassette") %>%
  dplyr::arrange(desc(n)) %>%
  dplyr::mutate(
    top_n = dplyr::row_number(),
    cumperc = cumsum(proportion)
  )

tmp <- hma_embedded_genes_attr_no_pseudo %>%
  dplyr::select(genome.accession, seqid, relative.position, Name) %>%
  dplyr::left_join(padlocout_master_sampled_no_overlaps, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
  group_by_position(col = relative.position, n = 1, name = "locus_id", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(locus_id = dplyr::cur_group_id(), .by = c("genome.accession", "seqid", "locus_id")) %>%
  group_by_position(col = relative.position, n = 1, name = "cassette_id", .by = "locus_id") %>%
  dplyr::mutate(cassette_id = dplyr::cur_group_id(), .by = c("locus_id", "cassette_id")) %>%
  dplyr::mutate(
    systems_in_cassette = paste0(unique(system), collapse = "++"),
    .by = c("cassette_id")
  ) %>%
  tidyr::nest(.by = c("cassette_id", "systems_in_cassette")) %>% 
  dplyr::summarise(n = dplyr::n(), .by = c("systems_in_cassette")) %>%
  dplyr::arrange(desc(n)) %>% 
  dplyr::mutate(systems_in_cassette = stringr::str_remove(systems_in_cassette, "NA\\+\\+|\\+\\+NA")) %>%
  # tidyr::separate_longer_delim(systems_in_cassette, "++") %>%
  dplyr::summarise(n = sum(n), .by = c("systems_in_cassette")) %>% 
  dplyr::arrange(desc(n), systems_in_cassette) %>%
  dplyr::filter(systems_in_cassette != "NA") %>%
  dplyr::mutate(n_perc = n/sum(n)*100)

# Total number of gene cassettes
hma_embedded_unknown %>% dplyr::summarise(n = sum(n))
# Number of different gene cassettes
hma_embedded_unknown %>% nrow()

# % of cassettes encoding known systems
# = cassettes w known / total cassettes
# = 243 / 1,005
# = 24.18%

ggplot(hma_embedded_unknown, aes(x = top_n, y = cumperc)) + 
  geom_line() +
  theme_classic() + 
  labs(
    x = "Top 'n' clusters by frequency", 
    y = "% of all sg clusters",
    # title = "There are several very common single-gene gene clusters",
    # subtitle = "Graph shows cumulative percentage"
  ) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.2), limits = c(0, 1), expand = expansion(mult = 0), labels = scales::percent_format(accuracy = 1)) +
  scale_x_continuous(breaks = seq(0, max(hma_embedded_unknown$top_n), by = 25), limits = c(0, NA), expand = expansion(mult = 0))+
  theme(text = element_text(size = 7),
        axis.text = element_text(colour = "black"),
        axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  geom_vline(xintercept = 34, colour = "red", linetype = "dashed") +
  geom_hline(yintercept = 0.5413, colour = "red", linetype = "dashed")

path <- fs::path_join(c(path_wd, "pdf/f1D.pdf"))
ggsave(filename = path, device = "pdf", width = 79.6, height = 79.6, units = "mm")

ggplot2::ggplot(hma_embedded_unknown, aes(x = top_n, y = n)) +
  geom_col() +
  theme_classic()



hma_embedded_top <- hma_embedded_unknown %>%
  dplyr::filter(n >= 5)

# Percentage of all embedded cassettes
hma_embedded_top %>% dplyr::summarise(proportion = sum(proportion)) %>% dplyr::pull(proportion)
# Number of distinct embedded cassettes
hma_embedded_top %>% nrow()

hma_embedded_top_families <- hma_embedded_top %>%
  dplyr::select(cassette) %>%
  tidyr::separate_longer_delim(cassette, delim = ">>") %>% 
  dplyr::rename(cluster = cassette) %>%
  dplyr::distinct()

hma_embedded_top_families_key <- hma_embedded_top_families %>% 
  dplyr::left_join(
    dplyr::mutate(extended_clusters, cluster = paste0("FAM_", stringr::str_pad(clu_ord_2, width = 5, pad = "0"))), 
    by = dplyr::join_by(cluster),
    multiple = "all"
  )

hma_embedded_top_families_key_unq_hmms <- hma_embedded_top_families_key %>% 
  dplyr::select(-clu_member) %>%
  dplyr::distinct() 

hmm_protein_key <- hma_embedded_top_families_key_unq_hmms %>% 
  dplyr::rename(hmm.name = clu_ord_1, protein.name = cluster) %>% 
  dplyr::select(hmm.name, protein.name)


candidate_system_models <- padlocdev::build_generic_padloc_models(
  hma_embedded_top_loci, 
  loci_col = cassette, 
  delim = ">>", 
  name_prefix = "CAND_"
)

candidate_system_sys_meta <- padlocdev::build_generic_sys_meta(candidate_system_models)

candidate_system_hmm_meta <- padlocdev::build_generic_hmm_meta(hmm_protein_key)

candidate_system_sys_models_path <- fs::path_join(c(path_wd, "embedded_candidates_padlocdb/sys"))
padlocdev::multi_write_padloc_model(candidate_system_models, candidate_system_sys_models_path)

candidate_system_sys_meta_path <- fs::path_join(c(path_wd, "embedded_candidates_padlocdb/sys_meta.txt"))
readr::write_tsv(candidate_system_sys_meta, candidate_system_sys_meta_path)

candidate_system_hmm_meta_path <- fs::path_join(c(path_wd, "embedded_candidates_padlocdb/hmm_meta.txt"))
readr::write_tsv(candidate_system_hmm_meta, candidate_system_hmm_meta_path)

```

```{r}
# CHECK VALIDITY OF GENERATED DATABASE
# ------------------------------------------------------------------------------

path_db <- fs::path_join(c(path_wd, "embedded_candidates_padlocdb"))
path_hmm <- fs::path_join(c(path_db, "hmm"))
path_sys <- fs::path_join(c(path_db, "sys"))
path_hmm_meta <- fs::path_join(c(path_db, "hmm_meta.txt"))
path_sys_meta <- fs::path_join(c(path_db, "sys_meta.txt"))

hmms <- padlocdev::multi_read_hmm_header(path_hmm)
models <- padlocdev::multi_read_padloc_model(path_sys)
hmm_meta <- padlocdev::read_hmm_meta(path_hmm_meta)
sys_meta <- padlocdev::read_sys_meta(path_sys_meta)

name_verification <- padlocdev::verify_hmm_names(hmms)
name_verification

hmm_files_hmm_meta_comparison <- padlocdev::compare_hmm_files_hmm_meta(hmms, hmm_meta)
hmm_files_hmm_meta_comparison

sys_files_sys_meta_comparison <- padlocdev::compare_sys_files_sys_meta(models, sys_meta)
sys_files_sys_meta_comparison

hmm_meta_expanded <- padlocdev::expand_hmm_meta(hmm_meta)
models_expanded <- padlocdev::expand_gene_groups_all(models, hmm_meta_expanded)

sys_files_hmm_meta_comparison <- padlocdev::compare_sys_files_hmm_meta(models_expanded, hmm_meta_expanded)
sys_files_hmm_meta_comparison

validity_report <- padlocdev::report_padloc_model_validity(models_expanded)
padlocdev::why_invalid(validity_report)

```

```{r}
# CHECK AGAINST ORIGINAL HECs

domtblout <- rhmmer::read_domtblout(fs::path_join(c(path_wd, "embedded_candidates_padlocdb/new_candidates_vs_original.domtblout")))

domtblout_top_hits_by_hmm <- domtblout %>% dplyr::slice_min(order_by = domain_ievalue, n = 1, by = query_name)

domtblout_top_hits_by_target <- domtblout %>% 
  dplyr::slice_min(order_by = domain_ievalue, n = 1, by = domain_name) %>%
  dplyr::mutate(
    hmm_cov = (hmm_to - hmm_from) / qlen,
    ali_cov = (ali_to - ali_from) / domain_len,
    .by = c(domain_name, query_name)
  ) %>%
  dplyr::select(c(domain_name, query_name, domain_ievalue, hmm_cov, ali_cov)) %>%
  dplyr::arrange(domain_name) %>%
  dplyr::left_join(hma_embedded_top_families_key_unq_hmms, by = dplyr::join_by(query_name == clu_ord_1)) %>%
  dplyr::select(-clu_ord_2) %>%
  # dplyr::mutate(system = stringr::str_extract(domain_name, "^HEC-[0-9]{2}")) %>%
  tidyr::separate_wider_delim(domain_name, delim = "_", names = c("system", "protein", "description")) %>%
  dplyr::mutate(cassette = paste0(cluster, collapse = ">>"), .by = system) %>%
  dplyr::left_join(hma_embedded_top_loci %>% dplyr::mutate(found = TRUE), by = dplyr::join_by(cassette))
 
domtblout_top_hits_by_target %>% 
  dplyr::mutate(
    dplyr::across(domain_ievalue, as.character),
    dplyr::across(c(hmm_cov, ali_cov), ~ round(.x, digits = 2))
    ) %>%
  dplyr::rename(family = cluster, locus = cassette, locus_is_candidate = found, ie_value = domain_ievalue) %>%
  dplyr::select(-query_name) %>%
  klip()

```

```{r}
# PROCESS HEC PADLOC RESULTS
# ------------------------------------------------------------------------------

# Read-in the padloc output table
path_padlocout_hecs <- fs::path_join(c(path_wd, "padlocout/2023_03_28_HMA_EMBEDDED_padloc.csv"))
padlocout_hecs <- read_padlocout_master(path_padlocout_hecs)

summarise_system_count(padlocout_hecs)

min_sg_ieval  <- 1e-50
min_sg_tarcov <- 0.75
min_sg_hmmcov <- 0.75

min_mg_ieval  <- 1e-25
min_mg_tarcov <- 0.5
min_mg_hmmcov <- 0.5

padlocout_hecs_filtered <- padlocout_hecs %>%
  mutate_system_id() %>%
  dplyr::mutate(n_genes = dplyr::n(), .by = system_id) %>%
  dplyr::mutate(
    drop = dplyr::if_else(
      n_genes == 1 & domain.iE.value > min_sg_ieval | 
        n_genes == 1 & target.coverage < min_sg_tarcov | 
        n_genes == 1 & hmm.coverage < min_sg_hmmcov |
        n_genes > 1 & domain.iE.value > min_mg_ieval | 
        n_genes > 1 & target.coverage < min_mg_tarcov | 
        n_genes > 1 & hmm.coverage < min_mg_hmmcov,
      TRUE, FALSE
    )
  ) %>%
  dplyr::filter(drop == FALSE) %>%
  dplyr::mutate(n_genes_post = dplyr::n(), .by = system_id) %>%
  dplyr::filter(n_genes == n_genes_post)

padlocout_hec_counts <- summarise_system_count(padlocout_hecs_filtered) %>% dplyr::arrange(desc(n))
hecs_above_threshold <- padlocout_hec_counts %>% dplyr::filter(n >= 100) %>% dplyr::pull(system)

padlocout_hecs_filtered_2 <- padlocout_hecs_filtered %>% 
  dplyr::filter(system %in% hecs_above_threshold)

tested_hecs_path <- "C:/Users/payle484/OneDrive - University of Otago/General - Phi Lab/Papers in preparation/Padloc/manuscript/dna_mod_systems/01_first_submission/supplementary_tables.xlsx"
tested_hecs <- readxl::read_xlsx(tested_hecs_path, sheet = 1)

padlocout_hecs_tested <- dplyr::left_join(tested_hecs, padlocout_hecs, by = dplyr::join_by(seqid, target.name))

padlocout_hecs_nested <- tidyr::nest(padlocout_hecs_filtered_2, .by = c(genome.accession, seqid, system, system.number))

padlocout_hecs_nested_2 <- padlocout_hecs_nested %>%
  dplyr::mutate(count = dplyr::n(), .by = c(genome.accession, system)) %>%
  tidyr::nest(.by = c(genome.accession, system, count))

pdlcout_collapsed <- pdlcout_filtered %>%
  group_by(seqid, system.number) %>%
  arrange(protein.name) %>%
  mutate(locus = paste0(protein.name, collapse = "__")) %>%
  distinct(genome.accession, seqid, system.number, system, locus) %>%
  group_by(genome.accession, locus) %>%
  mutate(count = n()) %>%
  distinct(genome.accession, locus, .keep_all = TRUE) %>%
  select(genome.accession, locus, count) %>%
  filter(locus %in% top_loci)

```

```{r}
# DOWNLOAD GTDB TAXONOMY METADATA
# ------------------------------------------------------------------------------

url <- "https://data.gtdb.ecogenomic.org/releases/release207/207.0/bac120_metadata_r207.tar.gz"
file <- fs::path_join(c(path_wd, "taxonomy/bac120_metadata_r207.tar.gz"))
download.file(url, file)
untar(file, exdir = fs::path_join(c(path_wd, "taxonomy/bac120_metadata_r207")))

bac120_metadata_r207 <- readr::read_tsv(fs::path_join(c(path_wd, "taxonomy/bac120_metadata_r207/bac120_metadata_r207.tsv")))

url <- "https://data.gtdb.ecogenomic.org/releases/release207/207.0/ar53_metadata_r207.tar.gz"
file <- fs::path_join(c(path_wd, "taxonomy/ar53_metadata_r207.tar.gz"))
download.file(url, file)
untar(file, exdir = fs::path_join(c(path_wd, "taxonomy/ar53_metadata_r207")))

ar53_metadata_r207 <- readr::read_tsv(fs::path_join(c(path_wd, "taxonomy/ar53_metadata_r207/ar53_metadata_r207.tsv")))

combined_metadata_r207 <- dplyr::bind_rows(bac120_metadata_r207, ar53_metadata_r207)

combined_metadata_r207_separated <- tidyr::separate_wider_delim(
  combined_metadata_r207, cols = gtdb_taxonomy, delim = ";",
  names = c("gtdb_domain", "gtdb_phylum", "gtdb_class", "gtdb_order", "gtdb_family", "gtdb_genus", "gtdb_species")
)
  
combined_metadata_r207_RS <- dplyr::filter(combined_metadata_r207_separated, stringr::str_detect(accession, "^RS_*"))

combined_metadata_r207_acc <- dplyr::mutate(
  combined_metadata_r207_RS, 
  genome.accession = paste0(stringr::str_remove(accession, "^RS_"), "_", ncbi_assembly_name),
  .by = c(accession, ncbi_assembly_name)
)

combined_metadata_flagged <- dplyr::full_join(
  dplyr::select(refseq_db_index, - c(path_faa, path_gff)),
  combined_metadata_r207_acc,
  by = dplyr::join_by(genome.accession)
) %>%
  dplyr::mutate(
    in_gtdb = dplyr::if_else(!is.na(accession), TRUE, FALSE),
    in_rfv109 = dplyr::if_else(!is.na(chunk), TRUE, FALSE)
  )

combined_metadata_flagged %>% 
  dplyr::filter(!(in_gtdb == TRUE & in_rfv109 == FALSE)) %>%
  summarise_proportion(.by = c("in_gtdb", "in_rfv109"))

```

```{r}
# PREVALENCE HEATMAP
# ------------------------------------------------------------------------------

# WE ARE WORKING W/ REFSEQ VERSION 209 (AKA 109) BUT THE LATEST GTDB TAXONOMY
# IS FOR REFSEQ VERSION 207

taxonomy_counts <- combined_metadata_flagged %>%
  # count number of assemblies in each species
  dplyr::mutate(assembly_count = dplyr::n(), .by = gtdb_species)

padlocout_hecs_taxonomy <- taxonomy_counts %>% 
  dplyr::full_join(padlocout_hecs_nested_2, by = "genome.accession")

# padlocout_hecs_taxonomy %>% 
#   summarise_proportion(.by = c("in_gtdb", "in_rfv109", "has_systems")) %>%
#   dplyr::arrange(desc(in_gtdb), desc(in_rfv109), desc(has_systems))

# spread out so there's a row for every assembly/system combination
pdlcout_taxonomy_wide <- padlocout_hecs_taxonomy %>% 
  tidyr::pivot_wider(names_from = system, values_from = count)

locus_names <- pdlcout_taxonomy_wide %>% names() %>% grep("^CAND_*", ., value = TRUE)

pdlcout_taxonomy_long <- pdlcout_taxonomy_wide %>%
  tidyr::pivot_longer(dplyr::all_of(locus_names), names_to = "system", values_to = "count") %>%
  dplyr::select(-"NA")

tmp <- pdlcout_taxonomy_long %>%
  # count number of assemblies that contain a system
  dplyr::group_by(genome.accession, system) %>% 
  dplyr::mutate(count = ifelse(is.na(count), 0, count)) #%>%

tmpa <- tmp %>%  
  dplyr::mutate(contains.system = ifelse(count > 0, 1, 0))

tmp2 <- tmpa %>%
  # for each species/system combination, count number of assemblies with a system
  dplyr::group_by(gtdb_species, system) %>% 
  dplyr::mutate(representative.count = sum(contains.system))

tmp3 <- tmp2 %>%
  # calculate the ratio of assemblies with system to total assemblies
  dplyr::mutate(normalised.count = representative.count / assembly_count) %>%
  dplyr::filter(dplyr::row_number() == 1) %>%
  # summarise 
  dplyr::group_by(gtdb_domain, gtdb_phylum, system) %>%
  dplyr::summarise(
    prevalence = mean(normalised.count),
    prevalence100 = mean(normalised.count) * 100,
    system.count = sum(representative.count),
    species.count = dplyr::n(), 
    genome.count = sum(assembly_count)
  ) %>%
  dplyr::mutate(system.count.2 = ifelse(system.count == 0, NA, system.count)) %>%
  dplyr::mutate(system.count.2 = ifelse(system.count.2 > 99, ">99", as.character(system.count.2)))

tmp4 <- tmp3 %>% 
  dplyr::filter(!is.na(gtdb_phylum)) %>%
  dplyr::filter(genome.count > 5) %>%
  dplyr::mutate(title = paste0(stringr::str_pad(gtdb_domain, 9, side = "right"), " ", stringr::str_pad(gtdb_phylum, 22, side = "right"), " ", stringr::str_pad(species.count, 6), " ", stringr::str_pad(genome.count, 8))) %>%
  dplyr::mutate(system.name = system) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(gtdb_phylum = stringr::str_remove(gtdb_phylum, "p__"))

tmp5 <- tmp4
tmp5[tmp4 == 0] <- NA

# y_axis_order <- tmp4 %>% arrange(gtdb.domain, genome.count, species.count) %>% distinct(title) %>% pull(title)
# y_axis_order <- tmp4 %>% arrange(gtdb.domain, genome.count, species.count) %>% distinct(gtdb.phylum) %>% pull(gtdb.phylum)
y_axis_order <- tmp4 %>% dplyr::arrange(desc(gtdb_domain), genome.count, species.count) %>% dplyr::distinct(gtdb_phylum) %>% dplyr::pull(gtdb_phylum)
# x_axis_order <- tmp4 %>% dplyr::arrange(system) %>% dplyr::distinct(system) %>% dplyr::pull(system)
x_axis_order <- hecs_above_threshold
# x_axis_order <- c(x_axis_order, "Hachiman variant", "Lamassu variant", "Septu variant", "Wadjet variant", "Zorya variant")

# PLOT HEATMAP OF PREVALENCE

library(ggplot2)
library(scales)

plot1 <- tmp5 %>% 
  # filter(!grepl("_other", system)) %>%
  # filter(!grepl("_var_", system)) %>%
  ggplot(aes(y = factor(system, level = rev(x_axis_order)), x = factor(gtdb_phylum, level = y_axis_order))) + 
  # geom_tile(aes(fill = ifelse(prevalence100 == 0, NA, prevalence100))) +
  # geom_tile(aes(fill = prevalence100), colour = "black", size = 0.2) +
  # geom_tile(aes(fill = prevalence100, colour = ifelse(prevalence100 == 0, NA, "black")), size = 0.5) +
  geom_tile(aes(fill = prevalence100), colour = "#1c1c1c") +
  # geom_text(aes(label = system.count.2), size = 2, colour = "black") +
  # geom_text(aes(label = ifelse(system.count == 0, NA, prettyNum(system.count, big.mark = ",", scientific = FALSE))), size = 2, colour = "black") +
  geom_text(aes(label = ifelse(prevalence == 0, NA, ceiling(prevalence100))), size = 2, colour = "black") +
  # scale_fill_viridis(discrete = FALSE, option = "viridis", direction = 1, limits = c(0, 10), oob = squish, na.value = "#ffffff") +
  scale_fill_gradient(low = "#fff5f3", high = "#d53f38", limits = c(0, 10), oob = squish, na.value = "#ffffff") +
  # scale_color_manual(values = c("black", NA)) +
  # scale_fill_viridis(discrete = FALSE, option = "viridis", direction = 1) +
  # theme_minimal() +
  scale_x_discrete(position = "top") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = -90, hjust = 1), 
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
    # axis.text.y = element_text(family = "mono"),
  )

plot1

plot2 <- tmp5 %>% 
  # filter(system == "druantia_type_III") %>%
  dplyr::distinct(gtdb_phylum, .keep_all = TRUE) %>%
  ggplot(aes(x = factor(system, level = x_axis_order), y = factor(gtdb_phylum, level = y_axis_order))) +
  geom_tile(aes(fill = log10(genome.count)), colour = "#1c1c1c") +
  # geom_text(aes(label = prettyNum(genome.count, big.mark = ",", scientific = FALSE)), size = 2, colour = "black") +
  geom_text(aes(label = genome.count), size = 2, colour = "black") +
  scale_fill_gradient(low = "#d7f4bc", high = "#3aa646", na.value = "#ffffff") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, colour = "#ffffff"),
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  guides(fill = "none")

plot2

cowplot::plot_grid(plot1, plot2, rel_widths = c(5, 1))

filepath <- fs::path_join(c(path_wd, "pdf/sf1.pdf"))
ggsave(filename = filepath, units = "cm", width = 32, height = 15)

top_families <- top_loci %>% str_split("__") %>% unlist() %>% unique()




# #### SAMPLE SYSTEMS FOR VISUALISATION OF NEIGHBOURHOOD
# 
# pdlcout_sample_test <- pdlcout_filtered %>%
#   group_by(seqid, system.number) %>%
#   arrange(protein.name) %>%
#   mutate(
#     locus_family = paste0(protein.name, collapse = "__"),
#     locus_cluster = paste0(hmm.name, collapse = "__")
#   ) %>%
#   distinct(genome.accession, seqid, system.number, system, locus_family, locus_cluster) %>%
#   group_by(genome.accession, locus_family) %>%
#   mutate(count = n()) %>%
#   distinct(genome.accession, locus_family, .keep_all = TRUE) %>%
#   select(genome.accession, locus_family, locus_cluster, count) %>%
#   filter(locus_family %in% top_loci)
# 
# pdlcout_sample_taxonomy <- pdlcout_sample_test %>% 
#   left_join(taxonomy_counts, by = "genome.accession")
# 
# pdlcout_sample <- pdlcout_sample_taxonomy %>% 
#   # shuffle order
#   slice(sample(1:n())) %>%
#   # deal w/ different loci individually
#   group_by(locus_cluster, gtdb.species) %>%
#   mutate(x = row_number()) %>%
#   ungroup() %>%
#   # select up to 5 examples for each species
#   filter(x <= 5) %>%
#   group_by(locus_cluster) %>%
#   # if # genomes still > 200, sample 200
#   sample_n(ifelse(n() > 200, 200, n()))
# 
# locus_counts <- pdlcout_sample %>% group_by(locus_family, locus_cluster) %>% summarise(n = n()) %>% arrange(locus_family, desc(n))
# 
# refseq_lookup <- read_tsv("/Volumes/HDD-02/sys_in_sys/data/tmp/refseq_lookup.txt", col_names = c("chunk", "genome.accession"))
# 
# pdlcout_sample2 <- pdlcout_sample %>% 
#   ungroup() %>% 
#   select(genome.accession) %>% 
#   distinct() %>% 
#   left_join(refseq_lookup, by = "genome.accession") %>%
#   select(chunk, genome.accession) %>%
#   arrange(chunk)
#   
# pdlcout_sample2 %>% write_tsv("/Volumes/HDD-02/sys_in_sys/data/sample_list.txt", col_names = FALSE)

```


```{r}
# CANDIDATES VS PFAM35 VISUALISATION
# ------------------------------------------------------------------------------

library(tidyverse)
library(gggenes)
library(wesanderson)

# read_family_key <- function(path) {
#   cols <- cols(gene = col_character(), member.name = col_character(), cluster.id = col_character(), family.id = col_character())
#   out <- read_tsv(path, col_names = names(cols$cols), col_types = cols)
# }

# read_sys_list <- function(path) {
#   cols <- cols(system.name = col_character(), cluster.id = col_character())
#   out <- read_tsv(path, col_names = names(cols$cols), col_types = cols) %>%
#     separate_rows(cluster.id, sep = ";")
# }

### HHsearch 50% ###

cath_resolve_hits_summarised_path <- fs::path_join(c(path_wd, "embedded_candidates_vs_pfam/cath/all.txt"))
cath_resolve_hits_summarised <- read_cath_resolve_hits_summarised(cath_resolve_hits_summarised_path)
cath_resolve_hits_processed <- cath_resolve_hits_process(cath_resolve_hits_summarised)

pfam_clans_path <- fs::path_join(c(path_wd, "../../shared/hhsuite-databases/Pfam35/Pfam-A.clans.tsv"))
pfam_clans <- read_pfam_clans(pfam_clans_path)

hhsearch_hhprob_path <- fs::path_join(c(path_wd, "embedded_candidates_vs_pfam/hhr/all.hhprob"))
hhsearch_hhprob <- read_hhsearch_hhprob(hhsearch_hhprob_path)
hhsearch_hhprob_prcessed <- hhsearch_hhprob_process(hhsearch_hhprob)

cluster_key_path <- fs::path_join(c(path_wd, "all_vs_all_hma_embedded/cluster_key.txt"))
cluster_key <- readr::read_tsv(cluster_key_path, col_names = c("family", "cluster", "query.id"), col_types = c("c", "c", "c"))

relevant_families <- padlocout_hecs_tested %>%
  dplyr::filter(candidate != "HEC-07") %>%
  dplyr::pull(protein.name)

# sys_list_path <- "/Volumes/SSD-01/02_working/sys_in_sys/data/003_pdef_padlocdb/sys_list.txt"
# sys_list <- read_sys_list(sys_list_path)

joined <- dplyr::left_join(cath_resolve_hits_processed, pfam_clans, by = c("target.id" = "family.id")) %>% 
  dplyr::left_join(hhsearch_hhprob_prcessed, by = dplyr::join_by(query.id, target.id, query.start, query.end)) %>%
  dplyr::left_join(cluster_key, by = dplyr::join_by(query.id)) %>%
  dplyr::mutate(family = paste0("FAM_", stringr::str_pad(family, 5, "left", "0"))) #%>%
  # dplyr::filter(family %in% relevant_families)

midpoints <- joined %>% 
  dplyr::rowwise() %>%
  dplyr::mutate(midpoint = (resolved.end + resolved.start) / 2) %>%
  dplyr::ungroup() 

y_axis_order <- midpoints %>% 
  dplyr::arrange(desc(family), desc(query.id)) %>% 
  dplyr::distinct(query.id) %>% 
  dplyr::pull(query.id)

ggplot(midpoints, aes(xmin = 0, xmax = query.length, y = factor(query.id, level = y_axis_order))) +
  # facet_wrap(~ system.name, scales = "fixed", ncol = 1) +
  gggenes::geom_gene_arrow(
    fill = NA,
    arrowhead_height = unit(3, "mm"), 
    arrowhead_width = unit(2, "mm")
  ) +
  gggenes::geom_subgene_arrow(
    data = midpoints,
    aes(xmin = 0, xmax = query.length, y = query.id, fill = clan.name, xsubmin = query.start, xsubmax = query.end),
    color = "black",
    arrowhead_height = unit(3, "mm"),
    arrowhead_width = unit(2, "mm")
  ) +
  # geom_subgene_label(
  #   data = b,
  #   aes(xsubmin = query.start, xsubmax = query.end, label = score), min.size = 0
  # ) +
  gggenes::geom_feature_label(
    data = midpoints,
    aes(x = midpoint, y = query.id, label = family.name),
  ) +
  # gggenes::geom_feature_label(
  #   data = midpoints,
  #   aes(x = midpoint, y = query.id, label = clan.name),
  # ) +
  # scale_fill_gradient2(
  #   low = "#3c9ab1",
  #   mid = "#e8c520",
  #   high = "#f22300",
  #   midpoint = 75,
  #   limits = c(50, 100),
  #   # breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1)
  # ) +
  # scale_fill_viridis_c(option = "A") +
  # scale_fill_gradient(low = "#ea4335", high = "#34a853", na.value = "#ffffff", limits = c(0, 100)) +
  gggenes::theme_genes()

# 210 mm x 297 mm (25.4 mm margins)
# = 159.2 mm x 246.2 mm
path <- fs::path_join(c(path_wd, "pdf/all_candidates_vs_pfam.pdf"))
ggsave(filename = path, device = "pdf", width = 318.4, height = 984.8, units = "mm")

### Individual HECs ###

cath_path <- "/Volumes/SSD-01/02_working/sys_in_sys/data/PDEF_hhsearch_HEC/cath/all.txt"
cath_results <- read_cathout(cath_path)
pfam_path <- "/Volumes/SSD-01/01_databases/PFAM/Pfam35/Pfam-A.clans.tsv"
pfam_stats <- read_pfam(pfam_path)
hhprob_path <- "/Volumes/SSD-01/02_working/sys_in_sys/data/PDEF_hhsearch_HEC/hhr/all.hhprob"
hhprob <- read_hhprob(hhprob_path)
key_path <- "/Volumes/SSD-01/02_working/sys_in_sys/data/003_pdef_padlocdb/families_key_top.txt"
key <- read_family_key(key_path)
sys_list_path <- "/Volumes/SSD-01/02_working/sys_in_sys/data/003_pdef_padlocdb/sys_list.txt"
sys_list <- read_sys_list(sys_list_path)

a <- left_join(cath_results, pfam_stats, by = c("target.id" = "family.id")) %>% 
  left_join(hhprob)

c <- b <- a %>% 
  mutate(target.number = row_number()) %>% 
  group_by(target.number) %>% 
  mutate(midpoint = (resolved.end + resolved.start)/2) %>%
  group_by()

y_axis_order <- c %>% arrange(desc(query.id)) %>% distinct(query.id) %>% pull(query.id)




```












```{r}
# INVESTIGATE WHICH SYSTEMS COMMONLY HAVE EMBEDDED GENES
# ------------------------------------------------------------------------------

# Read in the relevant system models, to figure out which systems could actually
# have embedded genes
sys <- padlocdev::multi_read_padloc_model("D:/payle484/padloc_update_230119/sys/")
sys_tbl <- tibble::tibble(system = names(sys), data = sys) %>%
  tidyr::unnest_wider(data)

# Figure out which systems have multiple genes, that were allowed to be separated
sys_w_separation <- sys_tbl %>% 
  dplyr::mutate(
    length_core = length(unlist(core_genes)),
    length_optional = dplyr::if_else(
      optional_genes != "NA", length(unlist(optional_genes)), 0
    ),
    length_total = length_core + length_optional,
    .by = "system"
  ) %>% 
  dplyr::filter(maximum_separation > 0 & length_total > 1) %>% 
  dplyr::pull(system)

# Filter for those systems
padlocout_master_no_overlaps_w_separation <-
  padlocout_master_no_overlaps %>%
  dplyr::filter(system %in% sys_w_separation)

# Figure out which of those systems actually had embedded genes
tmp1 <- padlocout_master_no_overlaps_w_separation %>%
  group_by_position(
    col = relative.position,
    n = 1,
    name = "tmp",
    .by = c("genome.accession", "seqid", "system.number", "system")
  )
tmp2 <- tmp1 %>%
  dplyr::mutate(
    has_embedded = dplyr::if_else(max(tmp) > 1, TRUE, FALSE),
    .by = c("genome.accession", "seqid", "system.number", "system")
  )

# Summarise
tmp3 <- tmp2 %>%
  dplyr::distinct(genome.accession, seqid, system, system.number, has_embedded) %>%
  dplyr::summarise(n = dplyr::n(), .by = c("system", "has_embedded")) %>%
  dplyr::arrange(system, desc(has_embedded), .locale = "en") %>%
  dplyr::mutate(p_embedded = round(n/sum(n)*100, 2), .by = "system") %>%
  dplyr::mutate(n_systems = sum(n), .by = "system") %>%
  dplyr::filter(has_embedded == TRUE) %>%
  dplyr::select(system, n_systems, n, p_embedded) %>%
  dplyr::rename(n_embedded = n) %>%
  dplyr::left_join(sys_tbl, by = dplyr::join_by(system)) %>%
  dplyr::mutate(
    n_core = length(unlist(core_genes)),
    n_optional = dplyr::if_else(
      optional_genes != "NA", length(unlist(optional_genes)), 0
    ),
    .by = "system"
  ) %>%
  dplyr::rename(max_sep = maximum_separation) %>%
  dplyr::select(system, n_systems, n_embedded, p_embedded, n_core, n_optional, max_sep)

# Order by most identified
order <- tmp3 %>% dplyr::arrange(n_systems) %>% dplyr::pull(system)
# Plots
ggplot(aes(x = "", y = n_perc, fill = factor(systems_in_cassette, level = order))) +
  geom_col(color = "black") +
  # geom_text(aes(label = n.norm), position = position_stack(vjust = 0.5)) +
  coord_flip() +
  theme_void() +
  scale_fill_viridis_d(NULL, begin = 0.2, end = 1, direction = -1, option = "rocket") +
  guides(fill = guide_legend(reverse = TRUE, ncol = 4)) +
  theme(legend.position = "bottom")

tmp3 %>%
  ggplot(aes(x = factor(system, level = order), y = p_embedded, fill = factor(system, level = order))) +
  geom_col(color = "black") +
  scale_fill_viridis_d(option = "turbo") +
  guides(fill = FALSE) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
  ) +
  xlab("System") +
  ylab("% w/ embedded genes")


```

```{r}
# INVESTIGATE THE EMBEDDED GENE ARRANGEMENTS OF HMA
# LOOKING AT ALL HMA SYSTEMS, NOT THE SUBSET!!!!!!!
# ------------------------------------------------------------------------------

# Lazily build loci for all HMA systems, w/ no surrounding genes
hma_loci_no_surrounding_redundant <- build_loci_lazy(padlocout_hma, 0)

# Drop 'other' models.
padlocout_master_no_other <- dplyr::filter(padlocout_master, !stringr::str_detect(system, "_other"))
# Drop CRISPR arrays and ncRNAs.
padlocout_master_no_ncrna <- dplyr::filter(padlocout_master_no_other, relative.position %% 1 == 0)
# Drop HECs.
padlocout_master_no_hecs <- dplyr::filter(padlocout_master_no_ncrna, !stringr::str_detect(system, "HEC"))

# Resolve overlapping systems.
padlocout_master_no_overlaps <-
  padlocout_resolve_overlaps(padlocout_master_no_hecs)

# Join this non-overlapping list of known systems onto the HMA systems w/ 
# embedded genes. There should be no warning or multiple matches, since we've
# resolved overlaps.
hma_loci_and_known <- hma_loci_no_surrounding_redundant %>%
  dplyr::select(genome.accession, seqid, relative.position) %>%
  dplyr::left_join(padlocout_master, by = dplyr::join_by(genome.accession, seqid, relative.position))

hma_loci_and_known_grouped <- hma_loci_and_known %>%
  group_by_position(col = relative.position, n = 1, name = "locus_id", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(locus_id = dplyr::cur_group_id(), .by = c("genome.accession", "seqid", "locus_id"))

# Check that no loci have been accidentally combined (this shouldn't occur, as 
# they should have been classified as a single system in the first place)
max(hma_loci_and_known_grouped$locus_id) == 
  hma_loci_and_known %>% 
  dplyr::distinct(genome.accession, seqid, system, system.number) %>%
  dplyr::filter(system == "hma") %>%
  nrow()

hma_embedded_cassettes <- hma_loci_and_known_grouped %>%
  dplyr::filter(system != "hma" | is.na(system)) %>%
  group_by_position(col = relative.position, n = 1, name = "cassette_id", .by = "locus_id") %>%
  dplyr::mutate(cassette_id = dplyr::cur_group_id(), .by = c("locus_id", "cassette_id"))

tmp1 <- hma_embedded_cassettes %>%
  dplyr::mutate(
    systems_in_cassette = paste0(unique(system), collapse = "++"),
    .by = c("cassette_id")
  ) %>%
  tidyr::nest(.by = c("cassette_id", "systems_in_cassette"))

tmp2 <- tmp1 %>% 
  dplyr::summarise(n = dplyr::n(), .by = c("systems_in_cassette")) %>%
  dplyr::arrange(desc(n))

tmp3 <- tmp2 %>% 
  tidyr::separate_longer_delim(systems_in_cassette, "++") %>%
  dplyr::summarise(n = sum(n), .by = c("systems_in_cassette")) %>% 
  dplyr::arrange(desc(n)) %>%
  dplyr::mutate(n_perc = n/sum(n)*100)

tmp4 <- tmp3 %>% 
  dplyr::filter(systems_in_cassette != "NA")

order <- tmp4 %>% dplyr::arrange(n) %>% dplyr::pull(systems_in_cassette)

tmp4 %>% 
  ggplot(aes(x = "", y = n_perc, fill = factor(systems_in_cassette, level = order))) +
  geom_col(color = "black") +
  # geom_text(aes(label = n.norm), position = position_stack(vjust = 0.5)) +
  coord_flip() +
  theme_void() +
  scale_fill_viridis_d(NULL, begin = 0.2, end = 1, direction = -1, option = "rocket") +
  guides(fill = guide_legend(reverse = TRUE, ncol = 4)) +
  theme(legend.position = "bottom")

```










```{r}

# 
# df <- tibble::tibble(
#   molecule = c("mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01"),
#   system   = c("sys_01", "sys_01", "sys_02", "sys_03", "sys_03", "sys_04", "sys_01", "sys_01", "sys_02", "sys_03", "sys_03", "sys_04"),
#   gene     = c("gen_01", "gen_02", "gen_03", "gen_04", "gen_05", "gen_06", "gen_01", "gen_02", "gen_03", "gen_04", "gen_05", "gen_06"),
#   position = c(       1,        2,        3,        1,        2,        2,        8,        9,       10,        8,        9,        9)
# )
# 
# df %>%
#   dplyr::group_by(molecule, position) %>%
#   dplyr::mutate(group = purrr::map_chr(position, ~paste(system[position == .x], collapse = ","))) %>%
#   dplyr::ungroup()
# 
# df %>%
#   dplyr::mutate(group = paste0(system, collapse = "_"), .by = c("molecule", "position")) %>%
#   dplyr::mutate(group2 = max(group), .by = c("molecule", "system"))
# 
# df %>%
#   dplyr::group_by(molecule) %>%
#   dplyr::mutate(group = dplyr::dense_rank(paste(pmin(position), pmax(position), sep = "_"))) %>%
#   dplyr::ungroup()
# 
# df %>%
#   dplyr::group_by(molecule, system) %>%
#   dplyr::mutate(tmp = list(position)) %>%
#   .$tmp
#   
# df %>%
#   dplyr::group_by(molecule) %>%
#   dplyr::arrange(position) %>%
#   dplyr::mutate(overlap_id = cumsum(c(1, abs(diff(position)) > 0)))
# 
# 
# df <- tibble::tibble(
#   molecule = c("mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01", "mol_01"),
#   system   = c("sys_01", "sys_01", "sys_02", "sys_03", "sys_03", "sys_04", "sys_01", "sys_01", "sys_02", "sys_03", "sys_03", "sys_04"),
#   gene     = c("gen_01", "gen_02", "gen_03", "gen_04", "gen_05", "gen_06", "gen_01", "gen_02", "gen_03", "gen_04", "gen_05", "gen_06"),
#   position = c(       1,        2,        3,        1,        2,        2,        8,        9,       10,        8,        9,        9),
#   group    = c("grp_01", "grp_01", "grp_02", "grp_01", "grp_01", "grp_01", "grp_03", "grp_03", "grp_04", "grp_03", "grp_03", "grp_03")
# )
# 





```

```{r}

# NO LONGER NECESSARY DUE TO DROPPING PSEUDOGENES COMPLETELY

# OPTIONAL: CHECK WHETHER THERE'S ANY PSEUDOGENE INFO MISSING
# ------------------------------------------------------------------------------

check <- hma_loci_clusters %>%
  # Is the protein an 'adjacent' protein (i.e. in the locus and not the primary system)?
  dplyr::mutate(is_adjacent = ifelse(is.na(target.name), TRUE, FALSE)) %>%
  dplyr::filter(is_adjacent == TRUE) %>%
  # Does the protein have the 'Name' attribute in the respective GFF file?
  # (pseudogenes won't unless we've put the substituted name in the GFF file).
  dplyr::mutate(has_name = ifelse(is.na(Name), FALSE, TRUE)) %>%
  # Does the protein have a cluster representative ?
  # (pseudogenes won't unless we've put the substituted sequence in the FASTA file)
  dplyr::mutate(has_clu_representative = ifelse(is.na(clu_representative), FALSE, TRUE))

check_summary <-
  dplyr::summarise(check, n = dplyr::n(), .by = c(is_adjacent, has_name, has_clu_representative))

check_filter <-
  dplyr::filter(check, has_name == FALSE | has_clu_representative == FALSE) %>%
  dplyr::select(genome.accession, seqid, start, end, strand, dup_representative, clu_representative, path_gff, is_adjacent, has_name, has_clu_representative) %>%
  dplyr::left_join(hma_loci %>% dplyr::select(genome.accession, seqid, start, end, strand, path_gff, attributes),
                   by = dplyr::join_by(genome.accession, seqid, start, end, strand, path_gff)) %>%
  gff_separate_attributes()

check_filter %>% dplyr::distinct(genome.accession) %>% nrow()

# Fill the cluster name column with the first non-NA value out of the 
# cluster names, protein names, and locus tags respectively, effectively
# assigning any missing cluster names with the protein name if they're an Hma 
# protein or the locus tag if they're an adjacent protein
hma_loci_clusters_filled <- dplyr::mutate(hma_loci_clusters, clu_representative = dplyr::coalesce(clu_representative, protein.name, locus_tag))
```

```{r}

# OLD ISLAND STUFF


# Add system limit information so genes don't accidentally get separated
# ~ 60s
padlocout_system_limits <- add_group_limits(
  padlocout_master_sampled_no_overlaps, 
  relative.position, 
  relative.position, 
  .by = c("genome.accession", "seqid", "system.number", "system")
)
# # ~ 60s
# padlocout_system_limits <- add_group_limits(
#   padlocout_system_limits, 
#   start, 
#   end, 
#   .by = c("genome.accession", "seqid", "system.number", "system")
# )

# Find islands
# ~ 60s
padlocout_islands_positions <- group_by_distance(
  padlocout_system_limits, 
  min_system_relative.position,
  max_system_relative.position, 
  n = 2, 
  name = "island", 
  .by = c("genome.accession", "seqid")
)
# # ~ 60s
# padlocout_islands_starts_ends <- group_by_distance(
#   padlocout_system_limits, 
#   min_system_start,
#   max_system_end, 
#   n = 10000, 
#   name = "island", 
#   .by = c("genome.accession", "seqid")
# )

padlocout_islands <- padlocout_islands_positions

# Count the number of systems in each island
# ~ 30s
padlocout_islands_n <- dplyr::mutate(
  padlocout_islands, 
  island_system_n = length(unique(system, system.number)), 
  .by = c("genome.accession", "seqid", "island")
)

padlocout_islands_nested <- tidyr::nest(
  padlocout_islands_n, 
  .by = c("genome.accession", "seqid", "island", "island_system_n", "system", "system.number")
)

# Filter for islands with hma
padlocout_islands_hma <- dplyr::filter(
  padlocout_islands_nested, 
  any(system %in% "hma"), 
  .by = c(genome.accession, seqid, island)
  ) %>% 
  dplyr::arrange(desc(island_system_n), genome.accession, seqid, island)

# # Filter for the non-redundant hma systems we sampled earlier
# padlocout_islands_hma_sample <- dplyr::filter(
#   padlocout_islands_hma,
#   genome.accession %in% sampled_genomes
# )

islands_hma_sample_unnested <- 
  tidyr::unnest(padlocout_islands_hma, data) %>%
  dplyr::arrange(genome.accession, seqid, relative.position)

tmp <- islands_hma_sample_unnested %>%
  group_by_position(
    col = relative.position,
    n = 1,
    name = "tmp",
    .by = c("genome.accession", "seqid", "system.number", "system")
  ) %>%
  dplyr::mutate(
    system_has_embedded = dplyr::if_else(max(tmp) > 1, TRUE, FALSE),
    .by = c("genome.accession", "seqid", "system.number", "system")
  ) %>%
  dplyr::mutate(
    island_has_hma_w_embedded = dplyr::if_else(any(system == "hma" & system_has_embedded == TRUE), TRUE, FALSE),
    .by = c("genome.accession", "seqid", "island")
  ) %>%
  dplyr::mutate(
    island_has_other_systems = dplyr::if_else(any(system != "hma"), TRUE, FALSE),
    .by = c("genome.accession", "seqid", "island")
  )

tmp2 <- tmp %>%
  tidyr::nest(.by = c("genome.accession", "seqid", "island", "island_has_hma_w_embedded", "island_has_other_systems"))

tmp2 %>% dplyr::summarise(n = dplyr::n(), .by = c("island_has_hma_w_embedded", "island_has_other_systems"))


```

```{r}
# ISLANDS IN ALL GENOMES (FOR FIGURE 1)
# ------------------------------------------------------------------------------

# Filter for contigs w/ HMA systems
padloc_master_w_hma <- padlocout_master %>% dplyr::filter(any(system == "hma"), .by = seqid)

# Drop 'other' models.
padlocout_master_no_other <- dplyr::filter(padloc_master_w_hma, !stringr::str_detect(system, "_other"))
# Drop CRISPR arrays and ncRNAs.
padlocout_master_no_ncrna <- dplyr::filter(padlocout_master_no_other, relative.position %% 1 == 0)
# Drop HECs.
padlocout_master_no_hecs <- dplyr::filter(padlocout_master_no_ncrna, !stringr::str_detect(system, "HEC"))

# Resolve overlapping systems.
padlocout_master_no_overlaps <- padlocout_resolve_overlaps(padlocout_master_no_hecs)

padlocout_system_limits <- add_group_limits(
  padlocout_master_no_overlaps, 
  relative.position, 
  relative.position, 
  .by = c("genome.accession", "seqid", "system.number", "system")
)

# Add columns for distance to contig ends
padlocout_contig_distance <- dplyr::mutate(
  padlocout_system_limits,
  distance_to_contig_start = min_system_relative.position - 1,
  distance_to_contig_end = contig.end - max_system_relative.position,
  min_distance_to_contig_border = min(distance_to_contig_start, distance_to_contig_end),
  max_distance_to_contig_border = max(distance_to_contig_start, distance_to_contig_end),
  .by = c("genome.accession", "seqid", "system.number", "system")
)

# Find islands
padlocout_islands_positions <- group_by_distance(
  padlocout_contig_distance, 
  min_system_relative.position,
  max_system_relative.position, 
  n = i, 
  name = "island", 
  .by = c("genome.accession", "seqid")
)

padlocout_islands_nested <- tidyr::nest(
  padlocout_islands_positions, 
  .by = c("genome.accession", "seqid", "island", "system", "system.number")
)

# Filter for islands with hma
padlocout_islands_hma <- dplyr::filter(
  padlocout_islands_nested, 
  any(system %in% "hma"), 
  .by = c(genome.accession, seqid, island)
) 

islands_hma_sample_unnested <- 
  tidyr::unnest(padlocout_islands_hma, data)

tmp <- islands_hma_sample_unnested %>%
  group_by_position(
    col = relative.position,
    n = 1,
    name = "tmp",
    .by = c("genome.accession", "seqid", "system.number", "system")
  ) %>%
  dplyr::left_join(
    hma_embedded_positions, 
    by = dplyr::join_by(genome.accession, seqid, relative.position)
  ) %>%
  dplyr::mutate(
    hma_w_embedded = dplyr::if_else(system == "hma" & max(tmp) > 1, TRUE, FALSE),
    .by = c("genome.accession", "seqid", "system.number", "system")
  ) %>%
  dplyr::mutate(
    hma_w_embedded = dplyr::if_else(any(hma_w_embedded == TRUE), TRUE, FALSE),
    hma_in_island = dplyr::if_else(any(system != "hma" & is.na(embedded_in_hma)), TRUE, FALSE),
    nsys = length(unique(system)),
    syss = paste0(unique(system), collapse = "__"),
    nemb = max(relative.position) - min(relative.position) - 3,
    min_distance_to_contig_border = min(min_distance_to_contig_border),
    .by = c("genome.accession", "seqid", "island") 
  )

# EXAMPLES WITH UNKNOWN EMBEDDED
# tmp2 <- tmp %>%
#   tidyr::nest(.by = c("genome.accession", "seqid", "island", "hma_w_embedded", "hma_in_island", "nsys", "syss", "nemb", "min_distance_to_contig_border")) %>%
#   dplyr::arrange(nsys, desc(nemb), desc(min_distance_to_contig_border)) %>%
#   dplyr::filter(hma_w_embedded == TRUE & hma_in_island == FALSE)

tmp2 <- tmp %>%
  tidyr::nest(.by = c("genome.accession", "seqid", "island", "hma_w_embedded", "hma_in_island", "nsys", "syss", "min_distance_to_contig_border")) %>%
  dplyr::arrange(desc(nsys), desc(min_distance_to_contig_border)) %>%
  dplyr::filter(hma_w_embedded == TRUE & hma_in_island == FALSE)

sample <- tmp2 %>%
  dplyr::slice_head(n = 3, by = "nemb")

info_for_sup <- tmp2 %>% 
  dplyr::filter(seqid %in% c("NZ_CP026674.1", "NZ_FXTF01000002.1", "NZ_KB894643.1", "NZ_KE387023.1", "NZ_LMFR01000025.1", "NZ_LSYZ01000050.1", "NZ_NPDI01000017.1", "NZ_CP012697.1", "NZ_CP081202.1", "NZ_KE734738.1", "NZ_LR792632.1")) %>%
  tidyr::unnest(data) %>%
  dplyr::mutate(hma_start = min(start), hma_end = max(end), .by = c(genome.accession, seqid, island)) %>% dplyr::distinct(genome.accession, seqid, hma_start, hma_end) %>%
  dplyr::rename(assembly_accession = genome.accession)

x <- sample$data[[3]]
idx <- 3

loci_list <- purrr::imap(
  
  .x = sample$data,
  
  .f = function(x, idx) {
    
    genome_accession <- sample[idx,]$genome.accession
    seqidd <- sample[idx,]$seqid
    hma_start <- x %>% dplyr::filter(system == "hma") %>% dplyr::pull(start) %>% min()
    hma_end <- x %>% dplyr::filter(system == "hma") %>% dplyr::pull(end) %>% max()
    
    gff_path <- refseq_db_index %>%
      dplyr::filter(genome.accession == genome_accession) %>% 
      dplyr::pull(path_gff) %>% 
      unique()
    gff_path <- fs::path_join(c(path_refseq_db, gff_path))
    
    gff <- read_gff(gff_path)
    gff_cds <- dplyr::filter(gff, type == "CDS")
    gff_cds_pos <- gff_mutate_relative_position(gff_cds)
    
    gff_filt <- gff_cds_pos %>% 
      dplyr::filter(seqid == seqidd & start >= hma_start - 20000 & end <= hma_end + 20000 ) %>%
      dplyr::mutate(direction = dplyr::if_else(strand == "+", 1, 0))
    
    out <- gff_filt %>% 
      dplyr::left_join(x, by = dplyr::join_by(start, end)) %>%
      dplyr::mutate(colour = dplyr::if_else(is.na(system), "#f1f3f8", dplyr::if_else(is.na(embedded_in_hma), "#f5b25f", "#71777f")))
    
  },
  
  .progress = TRUE
  
)

loci_list_bound <- dplyr::bind_rows(loci_list)
loci_list_bound_relative <- loci_list_bound %>%
  dplyr::mutate(relative_start = start - min(start), relative_end = end - min(start), .by = seqid)
  

library(ggplot2)
library(gggenes)

loci_list_bound_relative %>% 
  dplyr::mutate(locus_no = dplyr::cur_group_id(), .by = seqid) %>%
  # dplyr::filter(locus_no <= 17) %>%
  ggplot(aes(xmin = relative_start, xmax = relative_end, y = seqid, forward = direction, fill = colour)) +
  geom_gene_arrow(arrowhead_height = unit(3, "mm"), arrowhead_width = unit(1, "mm")) +
  # geom_gene_label(align = "left") +
  facet_wrap(~ seqid, scales = "free_y", ncol = 1) +
  # facet_wrap(~ seqid, ncol = 1) +
  # scale_fill_brewer(palette = "Set3") +
  scale_fill_identity() +
  theme_genes() +
  gggenes::geom_feature_label(
    data = loci_list_bound_relative,
    aes(x = relative_start, y = seqid, label = protein.name),
  )

# 210 mm x 297 mm (25.4 mm margins)
# = 159.2 mm x 246.2 mm
path <- fs::path_join(c(path_wd, "pdf/hma_loci_examples.pdf"))
ggsave(filename = path, device = "pdf", width = 318.4, height = 492.4, units = "mm")

```


```{r}
# RE-SUMMARISE THE KNOWN SYSTEMS EMBEDDED IN HMA SYSTEMS, ACCOUNTING FOR OUR
# NEW CANDIDATE SYSTEMS
# ------------------------------------------------------------------------------

# padlocout_master_no_overlaps_w_new_systems <- 
#   padlocout_master_sampled_no_overlaps %>%
#   dplyr::bind_rows(padlocout_new_systems) %>%
#   padlocout_resolve_overlaps()
# 
# tmp <- hma_embedded_genes_attr_no_pseudo %>%
#   dplyr::select(genome.accession, seqid, relative.position, Name) %>%
#   dplyr::left_join(padlocout_master_no_overlaps_w_new_systems, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
#   group_by_position(relative.position, n = 1, name = "embedded_cluster", .by = c("genome.accession", "seqid")) %>%
#   dplyr::mutate(embedded_cluster_id = dplyr::cur_group_id(), .by = c(genome.accession, seqid, embedded_cluster)) %>%
#   dplyr::mutate(cluster = paste0("FAM_", stringr::str_pad(clu_ord_2, width = 5, pad = "0"))) %>%
#   dplyr::arrange(cluster) %>%
#   dplyr::mutate(cassette = paste0(cluster, collapse = ">>"), .by = "embedded_cluster_id") %>%
#   tidyr::nest(.by = c(cassette, embedded_cluster_id)) %>%
#   summarise_proportion(.by = "cassette") %>%
#   dplyr::arrange(desc(n)) %>%
#   dplyr::mutate(
#     top_n = dplyr::row_number(),
#     cumperc = cumsum(proportion)
#   )
# 
# # tmp <- hma_embedded_genes_attr %>%
# #   dplyr::select(genome.accession, seqid, relative.position, Name) %>%
# #   dplyr::left_join(padlocout_master_no_overlaps_w_new_systems, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
# #   
# #   group_by_position(col = relative.position, n = 1, name = "locus_id", .by = c("genome.accession", "seqid")) %>%
# #   dplyr::mutate(locus_id = dplyr::cur_group_id(), .by = c("genome.accession", "seqid", "locus_id")) %>%
# #   group_by_position(col = relative.position, n = 1, name = "cassette_id", .by = "locus_id") %>%
# #   dplyr::mutate(cassette_id = dplyr::cur_group_id(), .by = c("locus_id", "cassette_id")) %>%
# #   dplyr::mutate(
# #     systems_in_cassette = paste0(unique(system), collapse = "++"),
# #     .by = c("cassette_id")
# #   ) %>%
# #   tidyr::nest(.by = c("cassette_id", "systems_in_cassette")) 

tmp <- hma_embedded_genes_attr_no_pseudo %>%
  dplyr::select(genome.accession, seqid, relative.position, Name) %>%
  dplyr::left_join(padlocout_master_no_overlaps, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
  group_by_position(col = relative.position, n = 1, name = "locus_id", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(locus_id = dplyr::cur_group_id(), .by = c("genome.accession", "seqid", "locus_id")) %>%
  group_by_position(col = relative.position, n = 1, name = "cassette_id", .by = "locus_id") %>%
  dplyr::mutate(cassette_id = dplyr::cur_group_id(), .by = c("locus_id", "cassette_id")) %>%
  dplyr::mutate(
    systems_in_cassette = paste0(unique(system), collapse = "++"),
    .by = c("cassette_id")
  ) %>%
  tidyr::nest(.by = c("cassette_id", "systems_in_cassette")) %>%
  dplyr::summarise(n = dplyr::n(), .by = c("systems_in_cassette")) %>%
  dplyr::arrange(desc(n)) %>%
  # tidyr::separate_longer_delim(systems_in_cassette, "++") %>%
  dplyr::summarise(n = sum(n), .by = c("systems_in_cassette")) %>%
  dplyr::arrange(desc(n)) %>%
  # dplyr::filter(systems_in_cassette != "NA") %>%
  dplyr::mutate(n_perc = n/sum(n)*100)

tmp %>%
  dplyr::rename(system = systems_in_cassette, proportion = n_perc) %>%
  dplyr::mutate(dplyr::across(proportion, ~ round(.x, digits = 2))) %>%
  klip()

# Number of known systems encoded by embedded gene casettes
tmp %>% dplyr::summarise(n = sum(n))

new_systems <- c("CAND_00001", "CAND_00002", "CAND_00003", "CAND_00004", "CAND_00010", "CAND_00011", "CAND_00014", "CAND_00021")

padlocout_new_systems <- padlocout_hecs_filtered %>% 
  dplyr::filter(system %in% new_systems)

hma_embedded_genes_attr_no_pseudo <-
  hma_embedded_genes_attr %>%
  dplyr::filter(!is.na(Name) & !stringr::str_detect(Name, "^pseudo_sub*"))

hma_embedded_unknown <- hma_embedded_genes_attr_no_pseudo %>%
  dplyr::select(genome.accession, seqid, relative.position, Name) %>%
  dplyr::left_join(padlocout_master_sampled_no_overlaps, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
  dplyr::left_join(extended_clusters, by = dplyr::join_by(Name == clu_member)) %>%
  # dplyr::filter(is.na(system)) %>%
  group_by_position(relative.position, n = 1, name = "embedded_cluster", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(embedded_cluster_id = dplyr::cur_group_id(), .by = c(genome.accession, seqid, embedded_cluster)) %>%
  dplyr::mutate(cluster = paste0("FAM_", stringr::str_pad(clu_ord_2, width = 5, pad = "0"))) %>%
  dplyr::arrange(cluster) %>%
  dplyr::mutate(cassette = paste0(cluster, collapse = ">>"), .by = "embedded_cluster_id") %>%
  tidyr::nest(.by = c(cassette, embedded_cluster_id)) %>%
  summarise_proportion(.by = "cassette") %>%
  dplyr::arrange(desc(n)) %>%
  dplyr::mutate(
    top_n = dplyr::row_number(),
    cumperc = cumsum(proportion)
  )

tmp <- hma_embedded_genes_attr_no_pseudo %>%
  dplyr::select(genome.accession, seqid, relative.position, Name) %>%
  dplyr::left_join(padlocout_master_no_overlaps_w_new_systems, by = dplyr::join_by(genome.accession, seqid, relative.position)) %>%
  group_by_position(col = relative.position, n = 1, name = "locus_id", .by = c("genome.accession", "seqid")) %>%
  dplyr::mutate(locus_id = dplyr::cur_group_id(), .by = c("genome.accession", "seqid", "locus_id")) %>%
  group_by_position(col = relative.position, n = 1, name = "cassette_id", .by = "locus_id") %>%
  dplyr::mutate(cassette_id = dplyr::cur_group_id(), .by = c("locus_id", "cassette_id")) %>%
  dplyr::mutate(
    systems_in_cassette = paste0(unique(system), collapse = "++"),
    .by = c("cassette_id")
  ) %>%
  tidyr::nest(.by = c("cassette_id", "systems_in_cassette")) %>% 
  dplyr::summarise(n = dplyr::n(), .by = c("systems_in_cassette")) %>%
  dplyr::arrange(desc(n)) %>% 
  dplyr::mutate(systems_in_cassette = stringr::str_remove(systems_in_cassette, "NA\\+\\+|\\+\\+NA")) %>%
  # tidyr::separate_longer_delim(systems_in_cassette, "++") %>%
  dplyr::summarise(n = sum(n), .by = c("systems_in_cassette")) %>% 
  dplyr::arrange(desc(n), systems_in_cassette) %>%
  # dplyr::filter(systems_in_cassette != "NA") %>%
  dplyr::mutate(n_perc = n/sum(n)*100)

tmp %>%
  dplyr::rename(system = systems_in_cassette, proportion = n_perc) %>%
  dplyr::mutate(dplyr::across(proportion, ~ round(.x, digits = 2))) %>%
  klip()

# PROPORTION OF CASSETTES W/ KNOWN SYS = 17.15%
# PROPORTION OF CASSETTES W/ KNOWN SYS AFTER HECs = 41.26%


order <- tmp %>% dplyr::arrange(n) %>% dplyr::pull(systems_in_cassette)

tmp %>% 
  ggplot(aes(x = "", y = n_perc, fill = factor(systems_in_cassette, level = order))) +
  geom_col(color = "black") +
  # geom_text(aes(label = n.norm), position = position_stack(vjust = 0.5)) +
  coord_flip() +
  theme_void() +
  scale_fill_viridis_d(NULL, begin = 0.2, end = 1, direction = -1, option = "rocket") +
  guides(fill = guide_legend(reverse = TRUE, ncol = 4)) +
  theme(legend.position = "bottom")


filepath <- fs::path_join(c(path_wd, "pdf/fu1.pdf"))
ggsave(filename = filepath, units = "mm", width = 246.2, height = 159.2)

```

```{r}
defensefinder_domtblout_dir <- fs::path_join(c(path_wd, "embedded_candidates_vs_defensefinder/domtblout"))

defensefinder_domtblout_files <- fs::dir_ls(defensefinder_domtblout_dir)

defensefinder_domtblouts <- purrr::map(defensefinder_domtblout_files, rhmmer::read_domtblout)

defensefinder_domtblout_bound <- dplyr::bind_rows(defensefinder_domtblouts)

tmp <- purrr::map_dfr(candidate_system_models, ~ tibble::as_tibble(.x), .id = "system") %>%
  dplyr::select(system, core_genes) %>%
  dplyr::left_join(
    extended_clusters %>% dplyr::mutate(core_genes = stringr::str_pad(clu_ord_2, width = 5, side = "left", pad = "0")),
    by = dplyr::join_by(core_genes), 
    relationship = "many-to-many"
  ) %>%
  dplyr::distinct(system, core_genes, clu_member) %>%
  dplyr::rename(gene = core_genes, target_name = clu_member) %>%
  dplyr::left_join(
    defensefinder_domtblout_bound, 
    by = dplyr::join_by(target_name == domain_name),
    relationship = "many-to-many"
  ) %>%
  dplyr::mutate(
      hmm_cov = (hmm_to - hmm_from) / qlen,
      ali_cov = (ali_to - ali_from) / domain_len
  ) %>%
  dplyr::select(system, gene, target_name, query_name, sequence_evalue, domain_ievalue, domain_score, hmm_cov, ali_cov) %>%
  dplyr::slice_min(order_by = domain_ievalue, by = c(system, gene, target_name), na_rm = FALSE, with_ties = FALSE) %>%
  klip()




padloc_domtblout_dir <- fs::path_join(c(path_wd, "embedded_candidates_vs_defensefinder/domtblout"))

padloc_domtblout_files <- fs::dir_ls(defensefinder_domtblout_dir)

padloc_domtblouts <- purrr::map(defensefinder_domtblout_files, rhmmer::read_domtblout)

padloc_domtblout_bound <- dplyr::bind_rows(defensefinder_domtblouts)

tmp <- purrr::map_dfr(candidate_system_models, ~ tibble::as_tibble(.x), .id = "system") %>%
  dplyr::select(system, core_genes) %>%
  dplyr::left_join(
    extended_clusters %>% dplyr::mutate(core_genes = stringr::str_pad(clu_ord_2, width = 5, side = "left", pad = "0")),
    by = dplyr::join_by(core_genes), 
    relationship = "many-to-many"
  ) %>%
  dplyr::distinct(system, core_genes, clu_member) %>%
  dplyr::rename(gene = core_genes, target_name = clu_member) %>%
  dplyr::left_join(
    defensefinder_domtblout_bound, 
    by = dplyr::join_by(target_name == domain_name),
    relationship = "many-to-many"
  ) %>%
  dplyr::mutate(
      hmm_cov = (hmm_to - hmm_from) / qlen,
      ali_cov = (ali_to - ali_from) / domain_len
  ) %>%
  dplyr::select(system, gene, target_name, query_name, sequence_evalue, domain_ievalue, domain_score, hmm_cov, ali_cov) %>%
  dplyr::slice_min(order_by = domain_ievalue, by = c(system, gene, target_name), na_rm = FALSE, with_ties = FALSE) %>%
  klip()

```

```{r}
# GENERATE SUPPLEMENTARY TABLES

sup2 <- padlocout_hecs_tested %>%
  dplyr::filter(candidate != "HEC-07") %>%
  dplyr::select(candidate, assembly.id, seqid, gtdb.phylum, gtdb.class, gtdb.order, gtdb.family, gtdb.genus.species, strain, protein.name, hmm.name, target.name, full.seq.E.value.y, domain.iE.value.y, target.coverage.y, hmm.coverage.y, start, end, strand, target.description, nucleotide.sequence, protein.sequence) %>%
  dplyr::rename(full.seq.E.value = full.seq.E.value.y, domain.iE.value = domain.iE.value.y, target.coverage = target.coverage.y, hmm.coverage = hmm.coverage.y, target.cluster = hmm.name, target.family = protein.name) %>%
  dplyr::mutate(target.family = stringr::str_remove(target.family, "FAM_"))

path <- fs::path_join(c(path_wd, "tables/supplementary_table_02.xlsx"))
writexl::write_xlsx(sup2, path)



hhcat_path <- fs::path_join(c(path_wd, "embedded_candidates_vs_pfam/hhr/all.hhcat"))
hhcat <- read_hhcat(hhcat_path)

hecs <- padlocout_hecs_tested %>%
  dplyr::filter(candidate != "HEC-07") %>%
  dplyr::select(candidate, hmm.name) %>%
  dplyr::rename(query_id = hmm.name)

family_key <- dplyr::distinct(cluster_key, family, cluster)

sup1 <- hhcat %>% 
  dplyr::left_join(family_key, by = dplyr::join_by(query_id == cluster)) %>%
  dplyr::left_join(pfam_clans, by = dplyr::join_by(match_id == family.id)) %>%
  dplyr::select(family, query_id, match_rank, match_id, clan.id, clan.name, family.name, description, prob, evalue, pvalue, score, alignment_query, query_hmm_length, alignment_match, match_hmm_length) %>%
  dplyr::rename(query_ali = alignment_query, query_len = query_hmm_length, match_ali = alignment_match, match_len = match_hmm_length, clan_id = clan.id, clan_name = clan.name, family_name = family.name) %>%
  dplyr::arrange(family, query_id, match_rank) %>%
  dplyr::mutate(match_len = as.double(stringr::str_remove_all(match_len, "\\(|\\)"))) %>%
  dplyr::mutate(family = stringr::str_pad(family, width = 5, side = "left", pad = "0"))

path <- fs::path_join(c(path_wd, "tables/supplementary_table_01.xlsx"))
writexl::write_xlsx(sup1, path)


```


```{r}
# SYSTEM EMBEDDING ACROSS ALL SYSTEM TYPES (CONSISTENT 5-GENE SEPARATION)

path <- fs::path_join(c(path_wd, "padlocout/5_spaces/padlocout_master.csv"))
padlocout_master_5 <- read_padlocout_master(path)

# Read in the relevant system models, to figure out which systems could actually
# have embedded genes
sys <- padlocdev::multi_read_padloc_model(fs::path_join(c(path_wd, "padlocout/5_spaces/sys/")))
sys_tbl <- tibble::tibble(system = names(sys), data = sys) %>%
  tidyr::unnest_wider(data)

# Figure out which systems have multiple genes, that were allowed to be separated
sys_w_separation <- sys_tbl %>% 
  dplyr::mutate(
    length_core = length(unlist(core_genes)),
    length_optional = dplyr::if_else(
      optional_genes != "NA", length(unlist(optional_genes)), 0
    ),
    length_total = length_core + length_optional,
    .by = "system"
  ) %>% 
  dplyr::filter(maximum_separation > 0 & length_total > 1) %>% 
  dplyr::pull(system)

# Filter out overlapping systems
padlocout_master_5_no_overlaps <- padlocout_resolve_overlaps(padlocout_master_5)

# Filter for those systems
padlocout_master_5_no_overlaps_multigene <-
  padlocout_master_5_no_overlaps %>%
  dplyr::filter(system %in% sys_w_separation)

# Figure out which of those systems actually had embedded genes
grouped <- padlocout_master_5_no_overlaps_multigene %>%
  group_by_position(
    col = relative.position,
    n = 1,
    name = "tmp",
    .by = c("genome.accession", "seqid", "system.number", "system")
  )

has_embedded <- grouped %>%
  dplyr::mutate(
    has_embedded = dplyr::if_else(max(tmp) > 1, TRUE, FALSE),
    .by = c("genome.accession", "seqid", "system.number", "system")
  )

# Summarise
summarised <- has_embedded %>%
  dplyr::distinct(genome.accession, seqid, system, system.number, has_embedded) %>%
  dplyr::summarise(n = dplyr::n(), .by = c("system", "has_embedded")) %>%
  dplyr::arrange(system, desc(has_embedded), .locale = "en") %>%
  dplyr::mutate(p_embedded = round(n/sum(n)*100, 2), .by = "system") %>%
  dplyr::mutate(n_systems = sum(n), .by = "system") %>%
  dplyr::filter(has_embedded == TRUE) %>%
  dplyr::select(system, n_systems, n, p_embedded) %>%
  dplyr::rename(n_embedded = n) %>%
  dplyr::left_join(sys_tbl, by = dplyr::join_by(system)) %>%
  dplyr::mutate(
    n_core = length(unlist(core_genes)),
    n_optional = dplyr::if_else(
      optional_genes != "NA", length(unlist(optional_genes)), 0
    ),
    .by = "system"
  ) %>%
  dplyr::rename(max_sep = maximum_separation) %>%
  dplyr::select(system, n_systems, n_embedded, p_embedded, n_core, n_optional, max_sep)

filtered <- summarised %>% dplyr::filter(!stringr::str_detect(system, "_other"))

order <- filtered %>% dplyr::arrange(desc(p_embedded)) %>% dplyr::pull(system)
order <- sys_tbl %>% dplyr::arrange(desc(minimum_total)) %>% dplyr::pull(system)

# Plots
# ggplot(aes(x = "", y = n_perc, fill = factor(systems_in_cassette, level = order))) +
#   geom_col(color = "black") +
#   # geom_text(aes(label = n.norm), position = position_stack(vjust = 0.5)) +
#   coord_flip() +
#   theme_void() +
#   scale_fill_viridis_d(NULL, begin = 0.2, end = 1, direction = -1, option = "rocket") +
#   guides(fill = guide_legend(reverse = TRUE, ncol = 4)) +
#   theme(legend.position = "bottom")

filtered %>%
  ggplot(aes(x = factor(system, level = order), y = p_embedded, fill = factor(system, level = order))) +
  geom_col(color = "black") +
  scale_fill_viridis_d(option = "turbo") +
  guides(fill = FALSE) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
  ) +
  xlab("System") +
  ylab("% w/ embedded genes")


```

```{r}
# CALCULATE DEFENCE-ICITY SCORES FOR HECS

padlocout_master_and_hecs <-
  dplyr::bind_rows(padlocout_master, padlocout_hecs_filtered_2)

padlocout_master_and_hecs_has_pseudo <- dplyr::mutate(
  padlocout_master_and_hecs,
  has_pseudo = dplyr::if_else(
    stringr::str_detect(target.name, "^pseudo_sub*"), TRUE, FALSE
  )
)

padlocout_master_and_hecs_no_pseudo <- dplyr::filter(
  padlocout_master_and_hecs_has_pseudo,
  all(has_pseudo == FALSE),
  .by = c(seqid, system, system.number)
)

padlocout_master_and_hecs_no_overlaps <- padlocout_resolve_overlaps(padlocout_master_and_hecs_no_pseudo)

padlocout_mhec_system_limits <- add_group_limits(
  padlocout_master_and_hecs_no_overlaps, 
  relative.position, 
  relative.position, 
  .by = c("genome.accession", "seqid", "system.number", "system")
)

padlocout_mhec_islands_positions <- group_by_distance(
  padlocout_mhec_system_limits, 
  min_system_relative.position,
  max_system_relative.position, 
  n = 5, 
  name = "island", 
  .by = c("genome.accession", "seqid")
)

padlocout_mhec_islands_nested <- tidyr::nest(
  padlocout_mhec_islands_positions, 
  .by = c("genome.accession", "seqid", "island", "system", "system.number")
)

padlocout_mhec_islands_hec <- dplyr::filter(
  padlocout_mhec_islands_nested, 
  any(stringr::str_detect(system, "^CAND")), 
  .by = c(genome.accession, seqid, island)
) 


islands_mhec_unnested <- 
  tidyr::unnest(padlocout_mhec_islands_hec, data)

tmp <- islands_mhec_unnested %>%
  # group_by_position(col = relative.position, n = 1, name = "tmp", .by = c("genome.accession", "seqid", "system.number", "system")) %>%
  dplyr::mutate(
    hec_in_island = dplyr::if_else(any(stringr::str_detect(system, "^CAND", negate = TRUE)), TRUE, FALSE),
    .by = c("genome.accession", "seqid", "island") 
  )

tmp2 <- tmp %>%
  tidyr::nest(.by = c("genome.accession", "seqid", "island", "system", "hec_in_island")) %>%
  dplyr::filter(stringr::str_detect(system, "^CAND"))

cand_filt <- padlocout_hecs_tested %>% 
  dplyr::select(candidate, system) %>% 
  dplyr::distinct() %>% 
  dplyr::filter(stringr::str_detect(candidate, "HEC-05|HEC-06|HEC-07", negate = TRUE)) %>%
  dplyr::bind_rows(tibble::tibble(candidate = "HEC-05/HEC-06", system = "CAND_00001"))

summary <- tmp2 %>%
  # dplyr::summarise(n = dplyr::n(), .by = c("system", "hec_in_island")) %>%
  summarise_n(.by = c("system", "hec_in_island")) %>%
  dplyr::mutate(proportion = n/sum(n), .by = system) %>%
  dplyr::left_join(cand_filt, by = dplyr::join_by(system)) %>%
  dplyr::arrange(desc(n), desc(hec_in_island)) %>%
  dplyr::filter(hec_in_island == TRUE)
  
  # dplyr::filter(!is.na(candidate))

summary






result <- purrr::map(.x = range, .f = function(i) {
  
  # Filter for relevant genomes
  padlocout_system_limits <- add_group_limits(
    padlocout_master_and_hecs_no_overlaps, 
    relative.position, 
    relative.position, 
    .by = c("genome.accession", "seqid", "system.number", "system")
  )
  
  # Find islands
  # ~ 60s
  padlocout_islands_positions <- group_by_distance(
    padlocout_system_limits, 
    min_system_relative.position,
    max_system_relative.position, 
    n = i, 
    name = "island", 
    .by = c("genome.accession", "seqid")
  )
  
  padlocout_islands_nested <- tidyr::nest(
    padlocout_islands_positions, 
    .by = c("genome.accession", "seqid", "island", "system", "system.number")
  )
  
  # Filter for islands with hma
  padlocout_islands_hec <- dplyr::filter(
    padlocout_islands_nested, 
    any(stringr::str_detect(system, "^CAND")), 
    .by = c(genome.accession, seqid, island)
  ) 
  
  islands_hec_unnested <- 
    tidyr::unnest(padlocout_islands_hec, data)
  
  tmp <- islands_hec_unnested %>%
    group_by_position(
      col = relative.position,
      n = 1,
      name = "tmp",
      .by = c("genome.accession", "seqid", "system.number", "system")
    ) %>%
    dplyr::left_join(
      hma_embedded_positions, 
      by = dplyr::join_by(genome.accession, seqid, relative.position)
    ) %>%
    dplyr::mutate(
      hma_w_embedded = dplyr::if_else(system == "hma" & max(tmp) > 1, TRUE, FALSE),
      .by = c("genome.accession", "seqid", "system.number", "system")
    ) %>%
    dplyr::mutate(
      hma_w_embedded = dplyr::if_else(any(hma_w_embedded == TRUE), TRUE, FALSE),
      hma_in_island = dplyr::if_else(any(system != "hma" & is.na(embedded_in_hma)), TRUE, FALSE),
      .by = c("genome.accession", "seqid", "island") 
    )
  
  tmp2 <- tmp %>%
    tidyr::nest(.by = c("genome.accession", "seqid", "island", "hma_w_embedded", "hma_in_island"))
  
  summary <- tmp2 %>%
    dplyr::summarise(n = dplyr::n(), .by = c("hma_w_embedded", "hma_in_island"))
  
  summary
  
}, .progress = TRUE)

result_bound <- purrr::imap(result, function(x, idx) dplyr::mutate(x, i = (idx - 1))) %>% dplyr::bind_rows()

result_bound_2 <- result_bound %>% dplyr::mutate(
  col1 = dplyr::if_else(hma_w_embedded, "w_embedded_genes", "wo_embedded_genes"),
  col2 = dplyr::if_else(hma_in_island, "in_island", "in_isolation")
)

df <- tibble::tibble(
  col1 = c(TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE),
  col2 = c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE),
  n = c(315, 131, 416, 608, 328, 148, 399, 595),
  i = c(1, 1, 1, 1, 2, 2, 2, 2)
)

result_bound_2 %>%
  ggplot2::ggplot(ggplot2::aes(x = factor(i), y = n)) +
  ggplot2::geom_bar(stat = "identity") +
  ggplot2::facet_grid(col1 ~ col2) +
  ggplot2::labs(x = "Island limits (no. of genes either side of Hma)", y = "Count") +
  ggplot2::theme_minimal()

result_bound_2 %>%
  
  dplyr::mutate(
    col_comb = factor(glue::glue("{col2}_{col1}")),
    order = stats::ave(n, col_comb, FUN = seq_along)
  ) %>%
  
  # dplyr::filter(
  #   dplyr::between(i, 1, 30)
  # ) %>%
  
  ggplot(., aes(x = as.factor(i), y = n, fill = col_comb)) +
  geom_bar(stat = "identity", position = "stack", alpha = 1, width = 1) +
  scale_fill_viridis_d(option = "mako", begin = 0.25, end = 1) +
  labs(x = "Island limits (no. of genes either side of Hma)", y = "Count", fill = "col_comb") +
  # facet_grid(~col1) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
  ) +
  theme_minimal() #+
  # guides(fill = FALSE)

# path_plot <- fs::path_join(c(path_wd, "pdf/F1_island_analysis.pdf"))
# ggsave(path_plot, width = 79.6, height = 79.6, units = "mm")

# Proportion of Hma systems in isolation
result_bound_2 %>% 
  dplyr::filter(i == 25) %>% 
  dplyr::mutate(proportion = n/sum(n)) %>% 
  dplyr::filter(col2 == "in_isolation") %>%
  dplyr::summarise(n = sum(n), proportion = sum(proportion)) %>%
  dplyr::pull(proportion)

# Proportion of Hma systems in isolation, that also have embedded genes
result_bound_2 %>% 
  dplyr::filter(i == 25) %>% 
  dplyr::filter(col2 == "in_isolation") %>%
  dplyr::mutate(proportion = n/sum(n)) %>%
  dplyr::filter(col1 == "w_embedded_genes") %>%
  dplyr::pull(proportion)

#### KNOWN SYSTEMS EMBEDDED

```











