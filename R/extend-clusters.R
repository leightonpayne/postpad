
#' Assign second order cluster identities to any first order clusters that did
#' not cluster with each other.
#'
#' Both the `first_order_clusters` and `second_order_clusters` tables should
#' have two columns, `clu_member` and `clu_representative`, where `clu_member`
#' contains the ID's of all elements that were clustered, and where
#' `clu_representative` contains the ID's of all resulting clusters - grouping
#' the respective elements together. The `clu_member` column of the
#' `second_order_clusters` should contain elements from the `clu_representative`
#' column of the `first_order_clusters`.
#'
#' @param first_order_clusters A table of first order clusters, such as that
#' generated by MMseqs2 and read-in w/ [read_mmseqs_cluster_tsv].
#' @param second_order_clusters A table of second order clusters, such as that
#' generated from an HHcat graph
#'
#' @export
extend_clusters <- function(first_order_clusters, second_order_clusters) {
  combined <- dplyr::left_join(
    first_order_clusters, second_order_clusters,
    by = c("clu_representative" = "clu_member"),
    suffix = c("_first_order", "_second_order")
  )
  max_cluster <- max(second_order_clusters$clu_representative)
  assigned <- dplyr::filter(combined, !is.na(clu_representative_second_order))
  unassigned <- dplyr::filter(combined, is.na(clu_representative_second_order))
  ununassigned <- dplyr::mutate(
    unassigned,
    clu_representative_second_order = dplyr::cur_group_id() + max_cluster,
    .by = "clu_representative"
  )
  bound <- dplyr::bind_rows(assigned, ununassigned)
  renamed <- dplyr::rename(bound, clu_ord_2 = clu_representative_second_order, clu_ord_1 = clu_representative)
  selected <- dplyr::select(renamed, clu_ord_2, clu_ord_1, clu_member)
  out <- dplyr::arrange(selected, clu_ord_2)
  out
}
